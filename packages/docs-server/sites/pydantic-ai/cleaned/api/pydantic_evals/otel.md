[ Skip to content ](#pydantic_evalsotel)
# `pydantic_evals.otel`
### SpanNode `dataclass`
A node in the span tree; provides references to parents/children for easy traversal and queries.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
```
| ```
@dataclass(repr=False, kw_only=True)
classSpanNode:
"""A node in the span tree; provides references to parents/children for easy traversal and queries."""
 name: str
 trace_id: int
 span_id: int
 parent_span_id: int | None
 start_timestamp: datetime
 end_timestamp: datetime
 attributes: dict[str, AttributeValue]
 @property
 defduration(self) -> timedelta:
"""Return the span's duration as a timedelta, or None if start/end not set."""
 return self.end_timestamp - self.start_timestamp
 @property
 defchildren(self) -> list[SpanNode]:
 return list(self.children_by_id.values())
 @property
 defdescendants(self) -> list[SpanNode]:
"""Return all descendants of this node in DFS order."""
 return self.find_descendants(lambda _: True)
 @property
 defancestors(self) -> list[SpanNode]:
"""Return all ancestors of this node."""
 return self.find_ancestors(lambda _: True)
 @property
 defnode_key(self) -> str:
 return f'{self.trace_id:032x}:{self.span_id:016x}'
 @property
 defparent_node_key(self) -> str | None:
 return None if self.parent_span_id is None else f'{self.trace_id:032x}:{self.parent_span_id:016x}'
 # -------------------------------------------------------------------------
 # Construction
 # -------------------------------------------------------------------------
 def__post_init__(self):
 self.parent: SpanNode | None = None
 self.children_by_id: dict[str, SpanNode] = {}
 @staticmethod
 deffrom_readable_span(span: ReadableSpan) -> SpanNode:
 assert span.context is not None, 'Span has no context'
 assert span.start_time is not None, 'Span has no start time'
 assert span.end_time is not None, 'Span has no end time'
 return SpanNode(
 name=span.name,
 trace_id=span.context.trace_id,
 span_id=span.context.span_id,
 parent_span_id=span.parent.span_id if span.parent else None,
 start_timestamp=datetime.fromtimestamp(span.start_time / 1e9, tz=timezone.utc),
 end_timestamp=datetime.fromtimestamp(span.end_time / 1e9, tz=timezone.utc),
 attributes=dict(span.attributes or {}),
 )
 defadd_child(self, child: SpanNode) -> None:
"""Attach a child node to this node's list of children."""
 assert child.trace_id == self.trace_id, f"traces don't match: {child.trace_id:032x} != {self.trace_id:032x}"
 assert child.parent_span_id == self.span_id, (
 f'parent span mismatch: {child.parent_span_id:016x} != {self.span_id:016x}'
 )
 self.children_by_id[child.node_key] = child
 child.parent = self
 # -------------------------------------------------------------------------
 # Child queries
 # -------------------------------------------------------------------------
 deffind_children(self, predicate: SpanQuery | SpanPredicate) -> list[SpanNode]:
"""Return all immediate children that satisfy the given predicate."""
 return list(self._filter_children(predicate))
 deffirst_child(self, predicate: SpanQuery | SpanPredicate) -> SpanNode | None:
"""Return the first immediate child that satisfies the given predicate, or None if none match."""
 return next(self._filter_children(predicate), None)
 defany_child(self, predicate: SpanQuery | SpanPredicate) -> bool:
"""Returns True if there is at least one child that satisfies the predicate."""
 return self.first_child(predicate) is not None
 def_filter_children(self, predicate: SpanQuery | SpanPredicate) -> Iterator[SpanNode]:
 return (child for child in self.children if child.matches(predicate))
 # -------------------------------------------------------------------------
 # Descendant queries (DFS)
 # -------------------------------------------------------------------------
 deffind_descendants(
 self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None
 ) -> list[SpanNode]:
"""Return all descendant nodes that satisfy the given predicate in DFS order."""
 return list(self._filter_descendants(predicate, stop_recursing_when))
 deffirst_descendant(
 self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None
 ) -> SpanNode | None:
"""DFS: Return the first descendant (in DFS order) that satisfies the given predicate, or `None` if none match."""
 return next(self._filter_descendants(predicate, stop_recursing_when), None)
 defany_descendant(
 self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None
 ) -> bool:
"""Returns `True` if there is at least one descendant that satisfies the predicate."""
 return self.first_descendant(predicate, stop_recursing_when) is not None
 def_filter_descendants(
 self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None
 ) -> Iterator[SpanNode]:
 stack = list(self.children)
 while stack:
 node = stack.pop()
 if node.matches(predicate):
 yield node
 if stop_recursing_when is not None and node.matches(stop_recursing_when):
 continue
 stack.extend(node.children)
 # -------------------------------------------------------------------------
 # Ancestor queries (DFS "up" the chain)
 # -------------------------------------------------------------------------
 deffind_ancestors(
 self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None
 ) -> list[SpanNode]:
"""Return all ancestors that satisfy the given predicate."""
 return list(self._filter_ancestors(predicate, stop_recursing_when))
 deffirst_ancestor(
 self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None
 ) -> SpanNode | None:
"""Return the closest ancestor that satisfies the given predicate, or `None` if none match."""
 return next(self._filter_ancestors(predicate, stop_recursing_when), None)
 defany_ancestor(
 self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None
 ) -> bool:
"""Returns True if any ancestor satisfies the predicate."""
 return self.first_ancestor(predicate, stop_recursing_when) is not None
 def_filter_ancestors(
 self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None
 ) -> Iterator[SpanNode]:
 node = self.parent
 while node:
 if node.matches(predicate):
 yield node
 if stop_recursing_when is not None and node.matches(stop_recursing_when):
 break
 node = node.parent
 # -------------------------------------------------------------------------
 # Query matching
 # -------------------------------------------------------------------------
 defmatches(self, query: SpanQuery | SpanPredicate) -> bool:
"""Check if the span node matches the query conditions or predicate."""
 if callable(query):
 return query(self)
 return self._matches_query(query)
 def_matches_query(self, query: SpanQuery) -> bool: # noqa C901
"""Check if the span matches the query conditions."""
 # Logical combinations
 if or_ := query.get('or_'):
 if len(query) > 1:
 raise ValueError("Cannot combine 'or_' conditions with other conditions at the same level")
 return any(self._matches_query(q) for q in or_)
 if not_ := query.get('not_'):
 if self._matches_query(not_):
 return False
 if and_ := query.get('and_'):
 results = [self._matches_query(q) for q in and_]
 if not all(results):
 return False
 # At this point, all existing ANDs and no existing ORs have passed, so it comes down to this condition
 # Name conditions
 if (name_equals := query.get('name_equals')) and self.name != name_equals:
 return False
 if (name_contains := query.get('name_contains')) and name_contains not in self.name:
 return False
 if (name_matches_regex := query.get('name_matches_regex')) and not re.match(name_matches_regex, self.name):
 return False
 # Attribute conditions
 if (has_attributes := query.get('has_attributes')) and not all(
 self.attributes.get(key) == value for key, value in has_attributes.items()
 ):
 return False
 if (has_attributes_keys := query.get('has_attribute_keys')) and not all(
 key in self.attributes for key in has_attributes_keys
 ):
 return False
 # Timing conditions
 if (min_duration := query.get('min_duration')) is not None:
 if not isinstance(min_duration, timedelta):
 min_duration = timedelta(seconds=min_duration)
 if self.duration < min_duration:
 return False
 if (max_duration := query.get('max_duration')) is not None:
 if not isinstance(max_duration, timedelta):
 max_duration = timedelta(seconds=max_duration)
 if self.duration > max_duration:
 return False
 # Children conditions
 if (min_child_count := query.get('min_child_count')) and len(self.children) < min_child_count:
 return False
 if (max_child_count := query.get('max_child_count')) and len(self.children) > max_child_count:
 return False
 if (some_child_has := query.get('some_child_has')) and not any(
 child._matches_query(some_child_has) for child in self.children
 ):
 return False
 if (all_children_have := query.get('all_children_have')) and not all(
 child._matches_query(all_children_have) for child in self.children
 ):
 return False
 if (no_child_has := query.get('no_child_has')) and any(
 child._matches_query(no_child_has) for child in self.children
 ):
 return False
 # Descendant conditions
 # The following local functions with cache decorators are used to avoid repeatedly evaluating these properties
 @cache
 defdescendants():
 return self.descendants
 @cache
 defpruned_descendants():
 stop_recursing_when = query.get('stop_recursing_when')
 return (
 self._filter_descendants(lambda _: True, stop_recursing_when) if stop_recursing_when else descendants()
 )
 if (min_descendant_count := query.get('min_descendant_count')) and len(descendants()) < min_descendant_count:
 return False
 if (max_descendant_count := query.get('max_descendant_count')) and len(descendants()) > max_descendant_count:
 return False
 if (some_descendant_has := query.get('some_descendant_has')) and not any(
 descendant._matches_query(some_descendant_has) for descendant in pruned_descendants()
 ):
 return False
 if (all_descendants_have := query.get('all_descendants_have')) and not all(
 descendant._matches_query(all_descendants_have) for descendant in pruned_descendants()
 ):
 return False
 if (no_descendant_has := query.get('no_descendant_has')) and any(
 descendant._matches_query(no_descendant_has) for descendant in pruned_descendants()
 ):
 return False
 # Ancestor conditions
 # The following local functions with cache decorators are used to avoid repeatedly evaluating these properties
 @cache
 defancestors():
 return self.ancestors
 @cache
 defpruned_ancestors():
 stop_recursing_when = query.get('stop_recursing_when')
 return self._filter_ancestors(lambda _: True, stop_recursing_when) if stop_recursing_when else ancestors()
 if (min_depth := query.get('min_depth')) and len(ancestors()) < min_depth:
 return False
 if (max_depth := query.get('max_depth')) and len(ancestors()) > max_depth:
 return False
 if (some_ancestor_has := query.get('some_ancestor_has')) and not any(
 ancestor._matches_query(some_ancestor_has) for ancestor in pruned_ancestors()
 ):
 return False
 if (all_ancestors_have := query.get('all_ancestors_have')) and not all(
 ancestor._matches_query(all_ancestors_have) for ancestor in pruned_ancestors()
 ):
 return False
 if (no_ancestor_has := query.get('no_ancestor_has')) and any(
 ancestor._matches_query(no_ancestor_has) for ancestor in pruned_ancestors()
 ):
 return False
 return True
 # -------------------------------------------------------------------------
 # String representation
 # -------------------------------------------------------------------------
 defrepr_xml(
 self,
 include_children: bool = True,
 include_trace_id: bool = False,
 include_span_id: bool = False,
 include_start_timestamp: bool = False,
 include_duration: bool = False,
 ) -> str:
"""Return an XML-like string representation of the node.
 Optionally includes children, trace_id, span_id, start_timestamp, and duration.
 """
 first_line_parts = [f'<SpanNode name={self.name!r}']
 if include_trace_id:
 first_line_parts.append(f"trace_id='{self.trace_id:032x}'")
 if include_span_id:
 first_line_parts.append(f"span_id='{self.span_id:016x}'")
 if include_start_timestamp:
 first_line_parts.append(f'start_timestamp={self.start_timestamp.isoformat()!r}')
 if include_duration:
 first_line_parts.append(f"duration='{self.duration}'")
 extra_lines: list[str] = []
 if include_children and self.children:
 first_line_parts.append('>')
 for child in self.children:
 extra_lines.append(
 indent(
 child.repr_xml(
 include_children=include_children,
 include_trace_id=include_trace_id,
 include_span_id=include_span_id,
 include_start_timestamp=include_start_timestamp,
 include_duration=include_duration,
 ),
 ' ',
 )
 )
 extra_lines.append('</SpanNode>')
 else:
 if self.children:
 first_line_parts.append('children=...')
 first_line_parts.append('/>')
 return '\n'.join([' '.join(first_line_parts), *extra_lines])
 def__str__(self) -> str:
 if self.children:
 return f"<SpanNode name={self.name!r} span_id='{self.span_id:016x}'>...</SpanNode>"
 else:
 return f"<SpanNode name={self.name!r} span_id='{self.span_id:016x}' />"
 def__repr__(self) -> str:
 return self.repr_xml()
```
---|--- 
#### duration `property`
```
duration: timedelta[](https://docs.python.org/3/library/datetime.html#datetime.timedelta "datetime.timedelta")
```
Return the span's duration as a timedelta, or None if start/end not set.
#### descendants `property`
```
descendants: list[](https://docs.python.org/3/library/stdtypes.html#list)[SpanNode[](#pydantic_evals.otel.SpanNode "pydantic_evals.otel.span_tree.SpanNode")]
```
Return all descendants of this node in DFS order.
#### ancestors `property`
```
ancestors: list[](https://docs.python.org/3/library/stdtypes.html#list)[SpanNode[](#pydantic_evals.otel.SpanNode "pydantic_evals.otel.span_tree.SpanNode")]
```
Return all ancestors of this node.
#### add_child
```
add_child(child: SpanNode[](#pydantic_evals.otel.SpanNode "pydantic_evals.otel.span_tree.SpanNode")) -> None
```
Attach a child node to this node's list of children.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
142
143
144
145
146
147
148
149
```
| ```
defadd_child(self, child: SpanNode) -> None:
"""Attach a child node to this node's list of children."""
 assert child.trace_id == self.trace_id, f"traces don't match: {child.trace_id:032x} != {self.trace_id:032x}"
 assert child.parent_span_id == self.span_id, (
 f'parent span mismatch: {child.parent_span_id:016x} != {self.span_id:016x}'
 )
 self.children_by_id[child.node_key] = child
 child.parent = self
```
---|--- 
#### find_children
```
find_children(
 predicate: SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate,
) -> list[](https://docs.python.org/3/library/stdtypes.html#list)[SpanNode[](#pydantic_evals.otel.SpanNode "pydantic_evals.otel.span_tree.SpanNode")]
```
Return all immediate children that satisfy the given predicate.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
154
155
156
```
| ```
deffind_children(self, predicate: SpanQuery | SpanPredicate) -> list[SpanNode]:
"""Return all immediate children that satisfy the given predicate."""
 return list(self._filter_children(predicate))
```
---|--- 
#### first_child
```
first_child(
 predicate: SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate,
) -> SpanNode[](#pydantic_evals.otel.SpanNode "pydantic_evals.otel.span_tree.SpanNode") | None
```
Return the first immediate child that satisfies the given predicate, or None if none match.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
158
159
160
```
| ```
deffirst_child(self, predicate: SpanQuery | SpanPredicate) -> SpanNode | None:
"""Return the first immediate child that satisfies the given predicate, or None if none match."""
 return next(self._filter_children(predicate), None)
```
---|--- 
#### any_child
```
any_child(predicate: SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate) -> bool[](https://docs.python.org/3/library/functions.html#bool)
```
Returns True if there is at least one child that satisfies the predicate.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
162
163
164
```
| ```
defany_child(self, predicate: SpanQuery | SpanPredicate) -> bool:
"""Returns True if there is at least one child that satisfies the predicate."""
 return self.first_child(predicate) is not None
```
---|--- 
#### find_descendants
```
find_descendants(
 predicate: SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate,
 stop_recursing_when: (
 SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate | None
 ) = None,
) -> list[](https://docs.python.org/3/library/stdtypes.html#list)[SpanNode[](#pydantic_evals.otel.SpanNode "pydantic_evals.otel.span_tree.SpanNode")]
```
Return all descendant nodes that satisfy the given predicate in DFS order.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
172
173
174
175
176
```
| ```
deffind_descendants(
 self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None
) -> list[SpanNode]:
"""Return all descendant nodes that satisfy the given predicate in DFS order."""
 return list(self._filter_descendants(predicate, stop_recursing_when))
```
---|--- 
#### first_descendant
```
first_descendant(
 predicate: SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate,
 stop_recursing_when: (
 SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate | None
 ) = None,
) -> SpanNode[](#pydantic_evals.otel.SpanNode "pydantic_evals.otel.span_tree.SpanNode") | None
```
DFS: Return the first descendant (in DFS order) that satisfies the given predicate, or `None` if none match.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
178
179
180
181
182
```
| ```
deffirst_descendant(
 self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None
) -> SpanNode | None:
"""DFS: Return the first descendant (in DFS order) that satisfies the given predicate, or `None` if none match."""
 return next(self._filter_descendants(predicate, stop_recursing_when), None)
```
---|--- 
#### any_descendant
```
any_descendant(
 predicate: SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate,
 stop_recursing_when: (
 SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate | None
 ) = None,
) -> bool[](https://docs.python.org/3/library/functions.html#bool)
```
Returns `True` if there is at least one descendant that satisfies the predicate.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
184
185
186
187
188
```
| ```
defany_descendant(
 self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None
) -> bool:
"""Returns `True` if there is at least one descendant that satisfies the predicate."""
 return self.first_descendant(predicate, stop_recursing_when) is not None
```
---|--- 
#### find_ancestors
```
find_ancestors(
 predicate: SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate,
 stop_recursing_when: (
 SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate | None
 ) = None,
) -> list[](https://docs.python.org/3/library/stdtypes.html#list)[SpanNode[](#pydantic_evals.otel.SpanNode "pydantic_evals.otel.span_tree.SpanNode")]
```
Return all ancestors that satisfy the given predicate.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
205
206
207
208
209
```
| ```
deffind_ancestors(
 self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None
) -> list[SpanNode]:
"""Return all ancestors that satisfy the given predicate."""
 return list(self._filter_ancestors(predicate, stop_recursing_when))
```
---|--- 
#### first_ancestor
```
first_ancestor(
 predicate: SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate,
 stop_recursing_when: (
 SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate | None
 ) = None,
) -> SpanNode[](#pydantic_evals.otel.SpanNode "pydantic_evals.otel.span_tree.SpanNode") | None
```
Return the closest ancestor that satisfies the given predicate, or `None` if none match.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
211
212
213
214
215
```
| ```
deffirst_ancestor(
 self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None
) -> SpanNode | None:
"""Return the closest ancestor that satisfies the given predicate, or `None` if none match."""
 return next(self._filter_ancestors(predicate, stop_recursing_when), None)
```
---|--- 
#### any_ancestor
```
any_ancestor(
 predicate: SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate,
 stop_recursing_when: (
 SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate | None
 ) = None,
) -> bool[](https://docs.python.org/3/library/functions.html#bool)
```
Returns True if any ancestor satisfies the predicate.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
217
218
219
220
221
```
| ```
defany_ancestor(
 self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None
) -> bool:
"""Returns True if any ancestor satisfies the predicate."""
 return self.first_ancestor(predicate, stop_recursing_when) is not None
```
---|--- 
#### matches
```
matches(query: SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate) -> bool[](https://docs.python.org/3/library/functions.html#bool)
```
Check if the span node matches the query conditions or predicate.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
237
238
239
240
241
242
```
| ```
defmatches(self, query: SpanQuery | SpanPredicate) -> bool:
"""Check if the span node matches the query conditions or predicate."""
 if callable(query):
 return query(self)
 return self._matches_query(query)
```
---|--- 
#### repr_xml
```
repr_xml(
 include_children: bool[](https://docs.python.org/3/library/functions.html#bool) = True,
 include_trace_id: bool[](https://docs.python.org/3/library/functions.html#bool) = False,
 include_span_id: bool[](https://docs.python.org/3/library/functions.html#bool) = False,
 include_start_timestamp: bool[](https://docs.python.org/3/library/functions.html#bool) = False,
 include_duration: bool[](https://docs.python.org/3/library/functions.html#bool) = False,
) -> str[](https://docs.python.org/3/library/stdtypes.html#str)
```
Return an XML-like string representation of the node.
Optionally includes children, trace_id, span_id, start_timestamp, and duration.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
```
| ```
defrepr_xml(
 self,
 include_children: bool = True,
 include_trace_id: bool = False,
 include_span_id: bool = False,
 include_start_timestamp: bool = False,
 include_duration: bool = False,
) -> str:
"""Return an XML-like string representation of the node.
 Optionally includes children, trace_id, span_id, start_timestamp, and duration.
 """
 first_line_parts = [f'<SpanNode name={self.name!r}']
 if include_trace_id:
 first_line_parts.append(f"trace_id='{self.trace_id:032x}'")
 if include_span_id:
 first_line_parts.append(f"span_id='{self.span_id:016x}'")
 if include_start_timestamp:
 first_line_parts.append(f'start_timestamp={self.start_timestamp.isoformat()!r}')
 if include_duration:
 first_line_parts.append(f"duration='{self.duration}'")
 extra_lines: list[str] = []
 if include_children and self.children:
 first_line_parts.append('>')
 for child in self.children:
 extra_lines.append(
 indent(
 child.repr_xml(
 include_children=include_children,
 include_trace_id=include_trace_id,
 include_span_id=include_span_id,
 include_start_timestamp=include_start_timestamp,
 include_duration=include_duration,
 ),
 ' ',
 )
 )
 extra_lines.append('</SpanNode>')
 else:
 if self.children:
 first_line_parts.append('children=...')
 first_line_parts.append('/>')
 return '\n'.join([' '.join(first_line_parts), *extra_lines])
```
---|--- 
### SpanQuery
Bases: `TypedDict[](https://typing-extensions.readthedocs.io/en/latest/index.html#typing_extensions.TypedDict "typing_extensions.TypedDict")`
A serializable query for filtering SpanNodes based on various conditions.
All fields are optional and combined with AND logic by default.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
```
| ```
classSpanQuery(TypedDict, total=False):
"""A serializable query for filtering SpanNodes based on various conditions.
 All fields are optional and combined with AND logic by default.
 """
 # These fields are ordered to match the implementation of SpanNode.matches_query for easy review.
 # * Individual span conditions come first because these are generally the cheapest to evaluate
 # * Logical combinations come next because they may just be combinations of individual span conditions
 # * Related-span conditions come last because they may require the most work to evaluate
 # Individual span conditions
 ## Name conditions
 name_equals: str
 name_contains: str
 name_matches_regex: str # regex pattern
 ## Attribute conditions
 has_attributes: dict[str, Any]
 has_attribute_keys: list[str]
 ## Timing conditions
 min_duration: timedelta | float
 max_duration: timedelta | float
 # Logical combinations of conditions
 not_: SpanQuery
 and_: list[SpanQuery]
 or_: list[SpanQuery]
 # Child conditions
 min_child_count: int
 max_child_count: int
 some_child_has: SpanQuery
 all_children_have: SpanQuery
 no_child_has: SpanQuery
 # Recursive conditions
 stop_recursing_when: SpanQuery
"""If present, stop recursing through ancestors or descendants at nodes that match this condition."""
 ## Descendant conditions
 min_descendant_count: int
 max_descendant_count: int
 some_descendant_has: SpanQuery
 all_descendants_have: SpanQuery
 no_descendant_has: SpanQuery
 ## Ancestor conditions
 min_depth: int # depth is equivalent to ancestor count; roots have depth 0
 max_depth: int
 some_ancestor_has: SpanQuery
 all_ancestors_have: SpanQuery
 no_ancestor_has: SpanQuery
```
---|--- 
#### stop_recursing_when `instance-attribute`
```
stop_recursing_when: SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery")
```
If present, stop recursing through ancestors or descendants at nodes that match this condition.
### SpanTree `dataclass`
A container that builds a hierarchy of SpanNode objects from a list of finished spans.
You can then search or iterate the tree to make your assertions (using DFS for traversal).
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
```
| ```
@dataclass(repr=False, kw_only=True)
classSpanTree:
"""A container that builds a hierarchy of SpanNode objects from a list of finished spans.
 You can then search or iterate the tree to make your assertions (using DFS for traversal).
 """
 roots: list[SpanNode] = field(default_factory=list)
 nodes_by_id: dict[str, SpanNode] = field(default_factory=dict)
 # -------------------------------------------------------------------------
 # Construction
 # -------------------------------------------------------------------------
 def__post_init__(self):
 self._rebuild_tree()
 defadd_spans(self, spans: list[SpanNode]) -> None:
"""Add a list of spans to the tree, rebuilding the tree structure."""
 for span in spans:
 self.nodes_by_id[span.node_key] = span
 self._rebuild_tree()
 defadd_readable_spans(self, readable_spans: list[ReadableSpan]):
 self.add_spans([SpanNode.from_readable_span(span) for span in readable_spans])
 def_rebuild_tree(self):
 # Ensure spans are ordered by start_timestamp so that roots and children end up in the right order
 nodes = list(self.nodes_by_id.values())
 nodes.sort(key=lambda node: node.start_timestamp or datetime.min)
 self.nodes_by_id = {node.node_key: node for node in nodes}
 # Build the parent/child relationships
 for node in self.nodes_by_id.values():
 parent_node_key = node.parent_node_key
 if parent_node_key is not None:
 parent_node = self.nodes_by_id.get(parent_node_key)
 if parent_node is not None:
 parent_node.add_child(node)
 # Determine the roots
 # A node is a "root" if its parent is None or if its parent's span_id is not in the current set of spans.
 self.roots = []
 for node in self.nodes_by_id.values():
 parent_node_key = node.parent_node_key
 if parent_node_key is None or parent_node_key not in self.nodes_by_id:
 self.roots.append(node)
 # -------------------------------------------------------------------------
 # Node filtering and iteration
 # -------------------------------------------------------------------------
 deffind(self, predicate: SpanQuery | SpanPredicate) -> list[SpanNode]:
"""Find all nodes in the entire tree that match the predicate, scanning from each root in DFS order."""
 return list(self._filter(predicate))
 deffirst(self, predicate: SpanQuery | SpanPredicate) -> SpanNode | None:
"""Find the first node that matches a predicate, scanning from each root in DFS order. Returns `None` if not found."""
 return next(self._filter(predicate), None)
 defany(self, predicate: SpanQuery | SpanPredicate) -> bool:
"""Returns True if any node in the tree matches the predicate."""
 return self.first(predicate) is not None
 def_filter(self, predicate: SpanQuery | SpanPredicate) -> Iterator[SpanNode]:
 for node in self:
 if node.matches(predicate):
 yield node
 def__iter__(self) -> Iterator[SpanNode]:
"""Return an iterator over all nodes in the tree."""
 return iter(self.nodes_by_id.values())
 # -------------------------------------------------------------------------
 # String representation
 # -------------------------------------------------------------------------
 defrepr_xml(
 self,
 include_children: bool = True,
 include_trace_id: bool = False,
 include_span_id: bool = False,
 include_start_timestamp: bool = False,
 include_duration: bool = False,
 ) -> str:
"""Return an XML-like string representation of the tree, optionally including children, trace_id, span_id, duration, and timestamps."""
 if not self.roots:
 return '<SpanTree />'
 repr_parts = [
 '<SpanTree>',
 *[
 indent(
 root.repr_xml(
 include_children=include_children,
 include_trace_id=include_trace_id,
 include_span_id=include_span_id,
 include_start_timestamp=include_start_timestamp,
 include_duration=include_duration,
 ),
 ' ',
 )
 for root in self.roots
 ],
 '</SpanTree>',
 ]
 return '\n'.join(repr_parts)
 def__str__(self):
 return f'<SpanTree num_roots={len(self.roots)} total_spans={len(self.nodes_by_id)} />'
 def__repr__(self):
 return self.repr_xml()
```
---|--- 
#### add_spans
```
add_spans(spans: list[](https://docs.python.org/3/library/stdtypes.html#list)[SpanNode[](#pydantic_evals.otel.SpanNode "pydantic_evals.otel.span_tree.SpanNode")]) -> None
```
Add a list of spans to the tree, rebuilding the tree structure.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
445
446
447
448
449
```
| ```
defadd_spans(self, spans: list[SpanNode]) -> None:
"""Add a list of spans to the tree, rebuilding the tree structure."""
 for span in spans:
 self.nodes_by_id[span.node_key] = span
 self._rebuild_tree()
```
---|--- 
#### find
```
find(
 predicate: SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate,
) -> list[](https://docs.python.org/3/library/stdtypes.html#list)[SpanNode[](#pydantic_evals.otel.SpanNode "pydantic_evals.otel.span_tree.SpanNode")]
```
Find all nodes in the entire tree that match the predicate, scanning from each root in DFS order.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
479
480
481
```
| ```
deffind(self, predicate: SpanQuery | SpanPredicate) -> list[SpanNode]:
"""Find all nodes in the entire tree that match the predicate, scanning from each root in DFS order."""
 return list(self._filter(predicate))
```
---|--- 
#### first
```
first(
 predicate: SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate,
) -> SpanNode[](#pydantic_evals.otel.SpanNode "pydantic_evals.otel.span_tree.SpanNode") | None
```
Find the first node that matches a predicate, scanning from each root in DFS order. Returns `None` if not found.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
483
484
485
```
| ```
deffirst(self, predicate: SpanQuery | SpanPredicate) -> SpanNode | None:
"""Find the first node that matches a predicate, scanning from each root in DFS order. Returns `None` if not found."""
 return next(self._filter(predicate), None)
```
---|--- 
#### any
```
any(predicate: SpanQuery[](#pydantic_evals.otel.SpanQuery "pydantic_evals.otel.span_tree.SpanQuery") | SpanPredicate) -> bool[](https://docs.python.org/3/library/functions.html#bool)
```
Returns True if any node in the tree matches the predicate.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
487
488
489
```
| ```
defany(self, predicate: SpanQuery | SpanPredicate) -> bool:
"""Returns True if any node in the tree matches the predicate."""
 return self.first(predicate) is not None
```
---|--- 
#### __iter__
```
__iter__() -> Iterator[](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterator "collections.abc.Iterator")[SpanNode[](#pydantic_evals.otel.SpanNode "pydantic_evals.otel.span_tree.SpanNode")]
```
Return an iterator over all nodes in the tree.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
496
497
498
```
| ```
def__iter__(self) -> Iterator[SpanNode]:
"""Return an iterator over all nodes in the tree."""
 return iter(self.nodes_by_id.values())
```
---|--- 
#### repr_xml
```
repr_xml(
 include_children: bool[](https://docs.python.org/3/library/functions.html#bool) = True,
 include_trace_id: bool[](https://docs.python.org/3/library/functions.html#bool) = False,
 include_span_id: bool[](https://docs.python.org/3/library/functions.html#bool) = False,
 include_start_timestamp: bool[](https://docs.python.org/3/library/functions.html#bool) = False,
 include_duration: bool[](https://docs.python.org/3/library/functions.html#bool) = False,
) -> str[](https://docs.python.org/3/library/stdtypes.html#str)
```
Return an XML-like string representation of the tree, optionally including children, trace_id, span_id, duration, and timestamps.
Source code in `pydantic_evals/pydantic_evals/otel/span_tree.py`
```
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
```
| ```
defrepr_xml(
 self,
 include_children: bool = True,
 include_trace_id: bool = False,
 include_span_id: bool = False,
 include_start_timestamp: bool = False,
 include_duration: bool = False,
) -> str:
"""Return an XML-like string representation of the tree, optionally including children, trace_id, span_id, duration, and timestamps."""
 if not self.roots:
 return '<SpanTree />'
 repr_parts = [
 '<SpanTree>',
 *[
 indent(
 root.repr_xml(
 include_children=include_children,
 include_trace_id=include_trace_id,
 include_span_id=include_span_id,
 include_start_timestamp=include_start_timestamp,
 include_duration=include_duration,
 ),
 ' ',
 )
 for root in self.roots
 ],
 '</SpanTree>',
 ]
 return '\n'.join(repr_parts)
```
---|---