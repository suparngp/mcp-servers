[ Skip to content ](#pydantic_aitoolsets)
# `pydantic_ai.toolsets`
### AbstractToolset
Bases: `ABC[](https://docs.python.org/3/library/abc.html#abc.ABC "abc.ABC")`, `Generic[](https://docs.python.org/3/library/typing.html#typing.Generic "typing.Generic")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]`
A toolset is a collection of tools that can be used by an agent.
It is responsible for:
 * Listing the tools it contains
 * Validating the arguments of the tools
 * Calling the tools
See [toolset docs](../../toolsets/) for more information.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`
```
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
```
| ```
classAbstractToolset(ABC, Generic[AgentDepsT]):
"""A toolset is a collection of tools that can be used by an agent.
 It is responsible for:
 - Listing the tools it contains
 - Validating the arguments of the tools
 - Calling the tools
 See [toolset docs](../toolsets.md) for more information.
 """
 @property
 @abstractmethod
 defid(self) -> str | None:
"""An ID for the toolset that is unique among all toolsets registered with the same agent.
 If you're implementing a concrete implementation that users can instantiate more than once, you should let them optionally pass a custom ID to the constructor and return that here.
 A toolset needs to have an ID in order to be used in a durable execution environment like Temporal, in which case the ID will be used to identify the toolset's activities within the workflow.
 """
 raise NotImplementedError()
 @property
 deflabel(self) -> str:
"""The name of the toolset for use in error messages."""
 label = self.__class__.__name__
 if self.id: # pragma: no branch
 label += f' {self.id!r}'
 return label
 @property
 deftool_name_conflict_hint(self) -> str:
"""A hint for how to avoid name conflicts with other toolsets for use in error messages."""
 return 'Rename the tool or wrap the toolset in a `PrefixedToolset` to avoid name conflicts.'
 async def__aenter__(self) -> Self:
"""Enter the toolset context.
 This is where you can set up network connections in a concrete implementation.
 """
 return self
 async def__aexit__(self, *args: Any) -> bool | None:
"""Exit the toolset context.
 This is where you can tear down network connections in a concrete implementation.
 """
 return None
 @abstractmethod
 async defget_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:
"""The tools that are available in this toolset."""
 raise NotImplementedError()
 @abstractmethod
 async defcall_tool(
 self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]
 ) -> Any:
"""Call a tool with the given arguments.
 Args:
 name: The name of the tool to call.
 tool_args: The arguments to pass to the tool.
 ctx: The run context.
 tool: The tool definition returned by [`get_tools`][pydantic_ai.toolsets.AbstractToolset.get_tools] that was called.
 """
 raise NotImplementedError()
 defapply(self, visitor: Callable[[AbstractToolset[AgentDepsT]], None]) -> None:
"""Run a visitor function on all "leaf" toolsets (i.e. those that implement their own tool listing and calling)."""
 visitor(self)
 defvisit_and_replace(
 self, visitor: Callable[[AbstractToolset[AgentDepsT]], AbstractToolset[AgentDepsT]]
 ) -> AbstractToolset[AgentDepsT]:
"""Run a visitor function on all "leaf" toolsets (i.e. those that implement their own tool listing and calling) and replace them in the hierarchy with the result of the function."""
 return visitor(self)
 deffiltered(
 self, filter_func: Callable[[RunContext[AgentDepsT], ToolDefinition], bool]
 ) -> FilteredToolset[AgentDepsT]:
"""Returns a new toolset that filters this toolset's tools using a filter function that takes the agent context and the tool definition.
 See [toolset docs](../toolsets.md#filtering-tools) for more information.
 """
 from.filteredimport FilteredToolset
 return FilteredToolset(self, filter_func)
 defprefixed(self, prefix: str) -> PrefixedToolset[AgentDepsT]:
"""Returns a new toolset that prefixes the names of this toolset's tools.
 See [toolset docs](../toolsets.md#prefixing-tool-names) for more information.
 """
 from.prefixedimport PrefixedToolset
 return PrefixedToolset(self, prefix)
 defprepared(self, prepare_func: ToolsPrepareFunc[AgentDepsT]) -> PreparedToolset[AgentDepsT]:
"""Returns a new toolset that prepares this toolset's tools using a prepare function that takes the agent context and the original tool definitions.
 See [toolset docs](../toolsets.md#preparing-tool-definitions) for more information.
 """
 from.preparedimport PreparedToolset
 return PreparedToolset(self, prepare_func)
 defrenamed(self, name_map: dict[str, str]) -> RenamedToolset[AgentDepsT]:
"""Returns a new toolset that renames this toolset's tools using a dictionary mapping new names to original names.
 See [toolset docs](../toolsets.md#renaming-tools) for more information.
 """
 from.renamedimport RenamedToolset
 return RenamedToolset(self, name_map)
 defapproval_required(
 self,
 approval_required_func: Callable[[RunContext[AgentDepsT], ToolDefinition, dict[str, Any]], bool] = (
 lambda ctx, tool_def, tool_args: True
 ),
 ) -> ApprovalRequiredToolset[AgentDepsT]:
"""Returns a new toolset that requires (some) calls to tools it contains to be approved.
 See [toolset docs](../toolsets.md#requiring-tool-approval) for more information.
 """
 from.approval_requiredimport ApprovalRequiredToolset
 return ApprovalRequiredToolset(self, approval_required_func)
```
---|--- 
#### id `abstractmethod` `property`
```
id: str[](https://docs.python.org/3/library/stdtypes.html#str) | None
```
An ID for the toolset that is unique among all toolsets registered with the same agent.
If you're implementing a concrete implementation that users can instantiate more than once, you should let them optionally pass a custom ID to the constructor and return that here.
A toolset needs to have an ID in order to be used in a durable execution environment like Temporal, in which case the ID will be used to identify the toolset's activities within the workflow.
#### label `property`
```
label: str[](https://docs.python.org/3/library/stdtypes.html#str)
```
The name of the toolset for use in error messages.
#### tool_name_conflict_hint `property`
```
tool_name_conflict_hint: str[](https://docs.python.org/3/library/stdtypes.html#str)
```
A hint for how to avoid name conflicts with other toolsets for use in error messages.
#### __aenter__ `async`
```
__aenter__() -> Self[](https://typing-extensions.readthedocs.io/en/latest/index.html#typing_extensions.Self "typing_extensions.Self")
```
Enter the toolset context.
This is where you can set up network connections in a concrete implementation.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`
```
 98
 99
100
101
102
103
```
| ```
async def__aenter__(self) -> Self:
"""Enter the toolset context.
 This is where you can set up network connections in a concrete implementation.
 """
 return self
```
---|--- 
#### __aexit__ `async`
```
__aexit__(*args: Any[](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any")) -> bool[](https://docs.python.org/3/library/functions.html#bool) | None
```
Exit the toolset context.
This is where you can tear down network connections in a concrete implementation.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`
```
105
106
107
108
109
110
```
| ```
async def__aexit__(self, *args: Any) -> bool | None:
"""Exit the toolset context.
 This is where you can tear down network connections in a concrete implementation.
 """
 return None
```
---|--- 
#### get_tools `abstractmethod` `async`
```
get_tools(
 ctx: RunContext[](../tools/#pydantic_ai.tools.RunContext "pydantic_ai._run_context.RunContext")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")],
) -> dict[](https://docs.python.org/3/library/stdtypes.html#dict)[str[](https://docs.python.org/3/library/stdtypes.html#str), ToolsetTool[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]]
```
The tools that are available in this toolset.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`
```
112
113
114
115
```
| ```
@abstractmethod
async defget_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:
"""The tools that are available in this toolset."""
 raise NotImplementedError()
```
---|--- 
#### call_tool `abstractmethod` `async`
```
call_tool(
 name: str[](https://docs.python.org/3/library/stdtypes.html#str),
 tool_args: dict[](https://docs.python.org/3/library/stdtypes.html#dict)[str[](https://docs.python.org/3/library/stdtypes.html#str), Any[](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any")],
 ctx: RunContext[](../tools/#pydantic_ai.tools.RunContext "pydantic_ai._run_context.RunContext")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")],
 tool: ToolsetTool[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")],
) -> Any[](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any")
```
Call a tool with the given arguments.
Parameters:
Name | Type | Description | Default 
---|---|---|--- 
`name` | `str[](https://docs.python.org/3/library/stdtypes.html#str)` | The name of the tool to call. | _required_ 
`tool_args` | `dict[](https://docs.python.org/3/library/stdtypes.html#dict)[str[](https://docs.python.org/3/library/stdtypes.html#str), Any[](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any")]` | The arguments to pass to the tool. | _required_ 
`ctx` | `RunContext[](../tools/#pydantic_ai.tools.RunContext "pydantic_ai._run_context.RunContext")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]` | The run context. | _required_ 
`tool` | `ToolsetTool[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]` | The tool definition returned by [`get_tools`](#pydantic_ai.toolsets.AbstractToolset.get_tools) that was called. | _required_ 
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`
```
117
118
119
120
121
122
123
124
125
126
127
128
129
```
| ```
@abstractmethod
async defcall_tool(
 self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]
) -> Any:
"""Call a tool with the given arguments.
 Args:
 name: The name of the tool to call.
 tool_args: The arguments to pass to the tool.
 ctx: The run context.
 tool: The tool definition returned by [`get_tools`][pydantic_ai.toolsets.AbstractToolset.get_tools] that was called.
 """
 raise NotImplementedError()
```
---|--- 
#### apply
```
apply(
 visitor: Callable[](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "collections.abc.Callable")[[AbstractToolset[](#pydantic_ai.toolsets.AbstractToolset "pydantic_ai.toolsets.abstract.AbstractToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]], None],
) -> None
```
Run a visitor function on all "leaf" toolsets (i.e. those that implement their own tool listing and calling).
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`
```
131
132
133
```
| ```
defapply(self, visitor: Callable[[AbstractToolset[AgentDepsT]], None]) -> None:
"""Run a visitor function on all "leaf" toolsets (i.e. those that implement their own tool listing and calling)."""
 visitor(self)
```
---|--- 
#### visit_and_replace
```
visit_and_replace(
 visitor: Callable[](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "collections.abc.Callable")[
 [AbstractToolset[](#pydantic_ai.toolsets.AbstractToolset "pydantic_ai.toolsets.abstract.AbstractToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]],
 AbstractToolset[](#pydantic_ai.toolsets.AbstractToolset "pydantic_ai.toolsets.abstract.AbstractToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")],
 ],
) -> AbstractToolset[](#pydantic_ai.toolsets.AbstractToolset "pydantic_ai.toolsets.abstract.AbstractToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]
```
Run a visitor function on all "leaf" toolsets (i.e. those that implement their own tool listing and calling) and replace them in the hierarchy with the result of the function.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`
```
135
136
137
138
139
```
| ```
defvisit_and_replace(
 self, visitor: Callable[[AbstractToolset[AgentDepsT]], AbstractToolset[AgentDepsT]]
) -> AbstractToolset[AgentDepsT]:
"""Run a visitor function on all "leaf" toolsets (i.e. those that implement their own tool listing and calling) and replace them in the hierarchy with the result of the function."""
 return visitor(self)
```
---|--- 
#### filtered
```
filtered(
 filter_func: Callable[](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "collections.abc.Callable")[
 [RunContext[](../tools/#pydantic_ai.tools.RunContext "pydantic_ai._run_context.RunContext")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")], ToolDefinition[](../tools/#pydantic_ai.tools.ToolDefinition "pydantic_ai.tools.ToolDefinition")], bool[](https://docs.python.org/3/library/functions.html#bool)
 ],
) -> FilteredToolset[](#pydantic_ai.toolsets.FilteredToolset "pydantic_ai.toolsets.filtered.FilteredToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]
```
Returns a new toolset that filters this toolset's tools using a filter function that takes the agent context and the tool definition.
See [toolset docs](../../toolsets/#filtering-tools) for more information.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`
```
141
142
143
144
145
146
147
148
149
150
```
| ```
deffiltered(
 self, filter_func: Callable[[RunContext[AgentDepsT], ToolDefinition], bool]
) -> FilteredToolset[AgentDepsT]:
"""Returns a new toolset that filters this toolset's tools using a filter function that takes the agent context and the tool definition.
 See [toolset docs](../toolsets.md#filtering-tools) for more information.
 """
 from.filteredimport FilteredToolset
 return FilteredToolset(self, filter_func)
```
---|--- 
#### prefixed
```
prefixed(prefix: str[](https://docs.python.org/3/library/stdtypes.html#str)) -> PrefixedToolset[](#pydantic_ai.toolsets.PrefixedToolset "pydantic_ai.toolsets.prefixed.PrefixedToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]
```
Returns a new toolset that prefixes the names of this toolset's tools.
See [toolset docs](../../toolsets/#prefixing-tool-names) for more information.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`
```
152
153
154
155
156
157
158
159
```
| ```
defprefixed(self, prefix: str) -> PrefixedToolset[AgentDepsT]:
"""Returns a new toolset that prefixes the names of this toolset's tools.
 See [toolset docs](../toolsets.md#prefixing-tool-names) for more information.
 """
 from.prefixedimport PrefixedToolset
 return PrefixedToolset(self, prefix)
```
---|--- 
#### prepared
```
prepared(
 prepare_func: ToolsPrepareFunc[](../tools/#pydantic_ai.tools.ToolsPrepareFunc "pydantic_ai.tools.ToolsPrepareFunc")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")],
) -> PreparedToolset[](#pydantic_ai.toolsets.PreparedToolset "pydantic_ai.toolsets.prepared.PreparedToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]
```
Returns a new toolset that prepares this toolset's tools using a prepare function that takes the agent context and the original tool definitions.
See [toolset docs](../../toolsets/#preparing-tool-definitions) for more information.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`
```
161
162
163
164
165
166
167
168
```
| ```
defprepared(self, prepare_func: ToolsPrepareFunc[AgentDepsT]) -> PreparedToolset[AgentDepsT]:
"""Returns a new toolset that prepares this toolset's tools using a prepare function that takes the agent context and the original tool definitions.
 See [toolset docs](../toolsets.md#preparing-tool-definitions) for more information.
 """
 from.preparedimport PreparedToolset
 return PreparedToolset(self, prepare_func)
```
---|--- 
#### renamed
```
renamed(
 name_map: dict[](https://docs.python.org/3/library/stdtypes.html#dict)[str[](https://docs.python.org/3/library/stdtypes.html#str), str[](https://docs.python.org/3/library/stdtypes.html#str)],
) -> RenamedToolset[](#pydantic_ai.toolsets.RenamedToolset "pydantic_ai.toolsets.renamed.RenamedToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]
```
Returns a new toolset that renames this toolset's tools using a dictionary mapping new names to original names.
See [toolset docs](../../toolsets/#renaming-tools) for more information.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`
```
170
171
172
173
174
175
176
177
```
| ```
defrenamed(self, name_map: dict[str, str]) -> RenamedToolset[AgentDepsT]:
"""Returns a new toolset that renames this toolset's tools using a dictionary mapping new names to original names.
 See [toolset docs](../toolsets.md#renaming-tools) for more information.
 """
 from.renamedimport RenamedToolset
 return RenamedToolset(self, name_map)
```
---|--- 
#### approval_required
```
approval_required(
 approval_required_func: Callable[](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "collections.abc.Callable")[
 [
 RunContext[](../tools/#pydantic_ai.tools.RunContext "pydantic_ai._run_context.RunContext")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")],
 ToolDefinition[](../tools/#pydantic_ai.tools.ToolDefinition "pydantic_ai.tools.ToolDefinition"),
 dict[](https://docs.python.org/3/library/stdtypes.html#dict)[str[](https://docs.python.org/3/library/stdtypes.html#str), Any[](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any")],
 ],
 bool[](https://docs.python.org/3/library/functions.html#bool),
 ] = lambda ctx, tool_def, tool_args: True
) -> ApprovalRequiredToolset[](#pydantic_ai.toolsets.ApprovalRequiredToolset "pydantic_ai.toolsets.approval_required.ApprovalRequiredToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]
```
Returns a new toolset that requires (some) calls to tools it contains to be approved.
See [toolset docs](../../toolsets/#requiring-tool-approval) for more information.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`
```
179
180
181
182
183
184
185
186
187
188
189
190
191
```
| ```
defapproval_required(
 self,
 approval_required_func: Callable[[RunContext[AgentDepsT], ToolDefinition, dict[str, Any]], bool] = (
 lambda ctx, tool_def, tool_args: True
 ),
) -> ApprovalRequiredToolset[AgentDepsT]:
"""Returns a new toolset that requires (some) calls to tools it contains to be approved.
 See [toolset docs](../toolsets.md#requiring-tool-approval) for more information.
 """
 from.approval_requiredimport ApprovalRequiredToolset
 return ApprovalRequiredToolset(self, approval_required_func)
```
---|--- 
### CombinedToolset `dataclass`
Bases: `AbstractToolset[](#pydantic_ai.toolsets.AbstractToolset "pydantic_ai.toolsets.abstract.AbstractToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]`
A toolset that combines multiple toolsets.
See [toolset docs](../../toolsets/#combining-toolsets) for more information.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/combined.py`
```
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
```
| ```
@dataclass
classCombinedToolset(AbstractToolset[AgentDepsT]):
"""A toolset that combines multiple toolsets.
 See [toolset docs](../toolsets.md#combining-toolsets) for more information.
 """
 toolsets: Sequence[AbstractToolset[AgentDepsT]]
 _enter_lock: Lock = field(compare=False, init=False, default_factory=Lock)
 _entered_count: int = field(init=False, default=0)
 _exit_stack: AsyncExitStack | None = field(init=False, default=None)
 @property
 defid(self) -> str | None:
 return None # pragma: no cover
 @property
 deflabel(self) -> str:
 return f'{self.__class__.__name__}({", ".join(toolset.labelfortoolsetinself.toolsets)})' # pragma: no cover
 async def__aenter__(self) -> Self:
 async with self._enter_lock:
 if self._entered_count == 0:
 async with AsyncExitStack() as exit_stack:
 for toolset in self.toolsets:
 await exit_stack.enter_async_context(toolset)
 self._exit_stack = exit_stack.pop_all()
 self._entered_count += 1
 return self
 async def__aexit__(self, *args: Any) -> bool | None:
 async with self._enter_lock:
 self._entered_count -= 1
 if self._entered_count == 0 and self._exit_stack is not None:
 await self._exit_stack.aclose()
 self._exit_stack = None
 async defget_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:
 toolsets_tools = await asyncio.gather(*(toolset.get_tools(ctx) for toolset in self.toolsets))
 all_tools: dict[str, ToolsetTool[AgentDepsT]] = {}
 for toolset, tools in zip(self.toolsets, toolsets_tools):
 for name, tool in tools.items():
 tool_toolset = tool.toolset
 if existing_tool := all_tools.get(name):
 capitalized_toolset_label = tool_toolset.label[0].upper() + tool_toolset.label[1:]
 raise UserError(
 f'{capitalized_toolset_label} defines a tool whose name conflicts with existing tool from {existing_tool.toolset.label}: {name!r}. {toolset.tool_name_conflict_hint}'
 )
 all_tools[name] = _CombinedToolsetTool(
 toolset=tool_toolset,
 tool_def=tool.tool_def,
 max_retries=tool.max_retries,
 args_validator=tool.args_validator,
 source_toolset=toolset,
 source_tool=tool,
 )
 return all_tools
 async defcall_tool(
 self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]
 ) -> Any:
 assert isinstance(tool, _CombinedToolsetTool)
 return await tool.source_toolset.call_tool(name, tool_args, ctx, tool.source_tool)
 defapply(self, visitor: Callable[[AbstractToolset[AgentDepsT]], None]) -> None:
 for toolset in self.toolsets:
 toolset.apply(visitor)
 defvisit_and_replace(
 self, visitor: Callable[[AbstractToolset[AgentDepsT]], AbstractToolset[AgentDepsT]]
 ) -> AbstractToolset[AgentDepsT]:
 return replace(self, toolsets=[toolset.visit_and_replace(visitor) for toolset in self.toolsets])
```
---|--- 
### ExternalToolset
Bases: `AbstractToolset[](#pydantic_ai.toolsets.AbstractToolset "pydantic_ai.toolsets.abstract.AbstractToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]`
A toolset that holds tools whose results will be produced outside of the Pydantic AI agent run in which they were called.
See [toolset docs](../../toolsets/#external-toolset) for more information.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/external.py`
```
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
```
| ```
classExternalToolset(AbstractToolset[AgentDepsT]):
"""A toolset that holds tools whose results will be produced outside of the Pydantic AI agent run in which they were called.
 See [toolset docs](../toolsets.md#external-toolset) for more information.
 """
 tool_defs: list[ToolDefinition]
 _id: str | None
 def__init__(self, tool_defs: list[ToolDefinition], *, id: str | None = None):
 self.tool_defs = tool_defs
 self._id = id
 @property
 defid(self) -> str | None:
 return self._id
 async defget_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:
 return {
 tool_def.name: ToolsetTool(
 toolset=self,
 tool_def=replace(tool_def, kind='external'),
 max_retries=0,
 args_validator=TOOL_SCHEMA_VALIDATOR,
 )
 for tool_def in self.tool_defs
 }
 async defcall_tool(
 self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]
 ) -> Any:
 raise NotImplementedError('External tools cannot be called directly')
```
---|--- 
### ApprovalRequiredToolset `dataclass`
Bases: `WrapperToolset[](#pydantic_ai.toolsets.WrapperToolset "pydantic_ai.toolsets.wrapper.WrapperToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]`
A toolset that requires (some) calls to tools it contains to be approved.
See [toolset docs](../../toolsets/#requiring-tool-approval) for more information.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/approval_required.py`
```
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
```
| ```
@dataclass
classApprovalRequiredToolset(WrapperToolset[AgentDepsT]):
"""A toolset that requires (some) calls to tools it contains to be approved.
 See [toolset docs](../toolsets.md#requiring-tool-approval) for more information.
 """
 approval_required_func: Callable[[RunContext[AgentDepsT], ToolDefinition, dict[str, Any]], bool] = (
 lambda ctx, tool_def, tool_args: True
 )
 async defcall_tool(
 self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]
 ) -> Any:
 if not ctx.tool_call_approved and self.approval_required_func(ctx, tool.tool_def, tool_args):
 raise ApprovalRequired
 return await super().call_tool(name, tool_args, ctx, tool)
```
---|--- 
### FilteredToolset `dataclass`
Bases: `WrapperToolset[](#pydantic_ai.toolsets.WrapperToolset "pydantic_ai.toolsets.wrapper.WrapperToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]`
A toolset that filters the tools it contains using a filter function that takes the agent context and the tool definition.
See [toolset docs](../../toolsets/#filtering-tools) for more information.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/filtered.py`
```
12
13
14
15
16
17
18
19
20
21
22
23
24
```
| ```
@dataclass
classFilteredToolset(WrapperToolset[AgentDepsT]):
"""A toolset that filters the tools it contains using a filter function that takes the agent context and the tool definition.
 See [toolset docs](../toolsets.md#filtering-tools) for more information.
 """
 filter_func: Callable[[RunContext[AgentDepsT], ToolDefinition], bool]
 async defget_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:
 return {
 name: tool for name, tool in (await super().get_tools(ctx)).items() if self.filter_func(ctx, tool.tool_def)
 }
```
---|--- 
### FunctionToolset
Bases: `AbstractToolset[](#pydantic_ai.toolsets.AbstractToolset "pydantic_ai.toolsets.abstract.AbstractToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]`
A toolset that lets Python functions be used as tools.
See [toolset docs](../../toolsets/#function-toolset) for more information.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/function.py`
```
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
```
| ```
classFunctionToolset(AbstractToolset[AgentDepsT]):
"""A toolset that lets Python functions be used as tools.
 See [toolset docs](../toolsets.md#function-toolset) for more information.
 """
 tools: dict[str, Tool[Any]]
 max_retries: int
 _id: str | None
 docstring_format: DocstringFormat
 require_parameter_descriptions: bool
 schema_generator: type[GenerateJsonSchema]
 def__init__(
 self,
 tools: Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] = [],
 *,
 max_retries: int = 1,
 docstring_format: DocstringFormat = 'auto',
 require_parameter_descriptions: bool = False,
 schema_generator: type[GenerateJsonSchema] = GenerateToolJsonSchema,
 strict: bool | None = None,
 sequential: bool = False,
 requires_approval: bool = False,
 metadata: dict[str, Any] | None = None,
 id: str | None = None,
 ):
"""Build a new function toolset.
 Args:
 tools: The tools to add to the toolset.
 max_retries: The maximum number of retries for each tool during a run.
 Applies to all tools, unless overridden when adding a tool.
 docstring_format: Format of tool docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].
 Defaults to `'auto'`, such that the format is inferred from the structure of the docstring.
 Applies to all tools, unless overridden when adding a tool.
 require_parameter_descriptions: If True, raise an error if a parameter description is missing. Defaults to False.
 Applies to all tools, unless overridden when adding a tool.
 schema_generator: The JSON schema generator class to use for this tool. Defaults to `GenerateToolJsonSchema`.
 Applies to all tools, unless overridden when adding a tool.
 strict: Whether to enforce JSON schema compliance (only affects OpenAI).
 See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.
 sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.
 Applies to all tools, unless overridden when adding a tool.
 requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.
 See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.
 Applies to all tools, unless overridden when adding a tool.
 metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.
 Applies to all tools, unless overridden when adding a tool, which will be merged with the toolset's metadata.
 id: An optional unique ID for the toolset. A toolset needs to have an ID in order to be used in a durable execution environment like Temporal,
 in which case the ID will be used to identify the toolset's activities within the workflow.
 """
 self.max_retries = max_retries
 self._id = id
 self.docstring_format = docstring_format
 self.require_parameter_descriptions = require_parameter_descriptions
 self.schema_generator = schema_generator
 self.strict = strict
 self.sequential = sequential
 self.requires_approval = requires_approval
 self.metadata = metadata
 self.tools = {}
 for tool in tools:
 if isinstance(tool, Tool):
 self.add_tool(tool)
 else:
 self.add_function(tool)
 @property
 defid(self) -> str | None:
 return self._id
 @overload
 deftool(self, func: ToolFuncEither[AgentDepsT, ToolParams], /) -> ToolFuncEither[AgentDepsT, ToolParams]: ...
 @overload
 deftool(
 self,
 /,
 *,
 name: str | None = None,
 description: str | None = None,
 retries: int | None = None,
 prepare: ToolPrepareFunc[AgentDepsT] | None = None,
 docstring_format: DocstringFormat | None = None,
 require_parameter_descriptions: bool | None = None,
 schema_generator: type[GenerateJsonSchema] | None = None,
 strict: bool | None = None,
 sequential: bool | None = None,
 requires_approval: bool | None = None,
 metadata: dict[str, Any] | None = None,
 ) -> Callable[[ToolFuncEither[AgentDepsT, ToolParams]], ToolFuncEither[AgentDepsT, ToolParams]]: ...
 deftool(
 self,
 func: ToolFuncEither[AgentDepsT, ToolParams] | None = None,
 /,
 *,
 name: str | None = None,
 description: str | None = None,
 retries: int | None = None,
 prepare: ToolPrepareFunc[AgentDepsT] | None = None,
 docstring_format: DocstringFormat | None = None,
 require_parameter_descriptions: bool | None = None,
 schema_generator: type[GenerateJsonSchema] | None = None,
 strict: bool | None = None,
 sequential: bool | None = None,
 requires_approval: bool | None = None,
 metadata: dict[str, Any] | None = None,
 ) -> Any:
"""Decorator to register a tool function which takes [`RunContext`][pydantic_ai.tools.RunContext] as its first argument.
 Can decorate a sync or async functions.
 The docstring is inspected to extract both the tool description and description of each parameter,
 [learn more](../tools.md#function-tools-and-schema).
 We can't add overloads for every possible signature of tool, since the return type is a recursive union
 so the signature of functions decorated with `@toolset.tool` is obscured.
 Example:
 ```python
 from pydantic_ai import Agent, FunctionToolset, RunContext
 toolset = FunctionToolset()
 @toolset.tool
 def foobar(ctx: RunContext[int], x: int) -> int:
 return ctx.deps + x
 @toolset.tool(retries=2)
 async def spam(ctx: RunContext[str], y: float) -> float:
 return ctx.deps + y
 agent = Agent('test', toolsets=[toolset], deps_type=int)
 result = agent.run_sync('foobar', deps=1)
 print(result.output)
 #> {"foobar":1,"spam":1.0}
 ```
 Args:
 func: The tool function to register.
 name: The name of the tool, defaults to the function name.
 description: The description of the tool,defaults to the function docstring.
 retries: The number of retries to allow for this tool, defaults to the agent's default retries,
 which defaults to 1.
 prepare: custom method to prepare the tool definition for each step, return `None` to omit this
 tool from a given step. This is useful if you want to customise a tool at call time,
 or omit it completely from a step. See [`ToolPrepareFunc`][pydantic_ai.tools.ToolPrepareFunc].
 docstring_format: The format of the docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].
 If `None`, the default value is determined by the toolset.
 require_parameter_descriptions: If True, raise an error if a parameter description is missing.
 If `None`, the default value is determined by the toolset.
 schema_generator: The JSON schema generator class to use for this tool.
 If `None`, the default value is determined by the toolset.
 strict: Whether to enforce JSON schema compliance (only affects OpenAI).
 See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.
 If `None`, the default value is determined by the toolset.
 sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.
 If `None`, the default value is determined by the toolset.
 requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.
 See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.
 If `None`, the default value is determined by the toolset.
 metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.
 If `None`, the default value is determined by the toolset. If provided, it will be merged with the toolset's metadata.
 """
 deftool_decorator(
 func_: ToolFuncEither[AgentDepsT, ToolParams],
 ) -> ToolFuncEither[AgentDepsT, ToolParams]:
 # noinspection PyTypeChecker
 self.add_function(
 func=func_,
 takes_ctx=None,
 name=name,
 description=description,
 retries=retries,
 prepare=prepare,
 docstring_format=docstring_format,
 require_parameter_descriptions=require_parameter_descriptions,
 schema_generator=schema_generator,
 strict=strict,
 sequential=sequential,
 requires_approval=requires_approval,
 metadata=metadata,
 )
 return func_
 return tool_decorator if func is None else tool_decorator(func)
 defadd_function(
 self,
 func: ToolFuncEither[AgentDepsT, ToolParams],
 takes_ctx: bool | None = None,
 name: str | None = None,
 description: str | None = None,
 retries: int | None = None,
 prepare: ToolPrepareFunc[AgentDepsT] | None = None,
 docstring_format: DocstringFormat | None = None,
 require_parameter_descriptions: bool | None = None,
 schema_generator: type[GenerateJsonSchema] | None = None,
 strict: bool | None = None,
 sequential: bool | None = None,
 requires_approval: bool | None = None,
 metadata: dict[str, Any] | None = None,
 ) -> None:
"""Add a function as a tool to the toolset.
 Can take a sync or async function.
 The docstring is inspected to extract both the tool description and description of each parameter,
 [learn more](../tools.md#function-tools-and-schema).
 Args:
 func: The tool function to register.
 takes_ctx: Whether the function takes a [`RunContext`][pydantic_ai.tools.RunContext] as its first argument. If `None`, this is inferred from the function signature.
 name: The name of the tool, defaults to the function name.
 description: The description of the tool, defaults to the function docstring.
 retries: The number of retries to allow for this tool, defaults to the agent's default retries,
 which defaults to 1.
 prepare: custom method to prepare the tool definition for each step, return `None` to omit this
 tool from a given step. This is useful if you want to customise a tool at call time,
 or omit it completely from a step. See [`ToolPrepareFunc`][pydantic_ai.tools.ToolPrepareFunc].
 docstring_format: The format of the docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].
 If `None`, the default value is determined by the toolset.
 require_parameter_descriptions: If True, raise an error if a parameter description is missing.
 If `None`, the default value is determined by the toolset.
 schema_generator: The JSON schema generator class to use for this tool.
 If `None`, the default value is determined by the toolset.
 strict: Whether to enforce JSON schema compliance (only affects OpenAI).
 See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.
 If `None`, the default value is determined by the toolset.
 sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.
 If `None`, the default value is determined by the toolset.
 requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.
 See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.
 If `None`, the default value is determined by the toolset.
 metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.
 If `None`, the default value is determined by the toolset. If provided, it will be merged with the toolset's metadata.
 """
 if docstring_format is None:
 docstring_format = self.docstring_format
 if require_parameter_descriptions is None:
 require_parameter_descriptions = self.require_parameter_descriptions
 if schema_generator is None:
 schema_generator = self.schema_generator
 if strict is None:
 strict = self.strict
 if sequential is None:
 sequential = self.sequential
 if requires_approval is None:
 requires_approval = self.requires_approval
 tool = Tool[AgentDepsT](
 func,
 takes_ctx=takes_ctx,
 name=name,
 description=description,
 max_retries=retries,
 prepare=prepare,
 docstring_format=docstring_format,
 require_parameter_descriptions=require_parameter_descriptions,
 schema_generator=schema_generator,
 strict=strict,
 sequential=sequential,
 requires_approval=requires_approval,
 metadata=metadata,
 )
 self.add_tool(tool)
 defadd_tool(self, tool: Tool[AgentDepsT]) -> None:
"""Add a tool to the toolset.
 Args:
 tool: The tool to add.
 """
 if tool.name in self.tools:
 raise UserError(f'Tool name conflicts with existing tool: {tool.name!r}')
 if tool.max_retries is None:
 tool.max_retries = self.max_retries
 if self.metadata is not None:
 tool.metadata = self.metadata | (tool.metadata or {})
 self.tools[tool.name] = tool
 async defget_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:
 tools: dict[str, ToolsetTool[AgentDepsT]] = {}
 for original_name, tool in self.tools.items():
 max_retries = tool.max_retries if tool.max_retries is not None else self.max_retries
 run_context = replace(
 ctx,
 tool_name=original_name,
 retry=ctx.retries.get(original_name, 0),
 max_retries=max_retries,
 )
 tool_def = await tool.prepare_tool_def(run_context)
 if not tool_def:
 continue
 new_name = tool_def.name
 if new_name in tools:
 if new_name != original_name:
 raise UserError(f'Renaming tool {original_name!r} to {new_name!r} conflicts with existing tool.')
 else:
 raise UserError(f'Tool name conflicts with previously renamed tool: {new_name!r}.')
 tools[new_name] = FunctionToolsetTool(
 toolset=self,
 tool_def=tool_def,
 max_retries=max_retries,
 args_validator=tool.function_schema.validator,
 call_func=tool.function_schema.call,
 is_async=tool.function_schema.is_async,
 )
 return tools
 async defcall_tool(
 self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]
 ) -> Any:
 assert isinstance(tool, FunctionToolsetTool)
 return await tool.call_func(tool_args, ctx)
```
---|--- 
#### __init__
```
__init__(
 tools: Sequence[](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "collections.abc.Sequence")[
 Tool[](../tools/#pydantic_ai.tools.Tool "pydantic_ai.tools.Tool")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")] | ToolFuncEither[](../tools/#pydantic_ai.tools.ToolFuncEither "pydantic_ai.tools.ToolFuncEither")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT"), ...]
 ] = [],
 *,
 max_retries: int[](https://docs.python.org/3/library/functions.html#int) = 1,
 docstring_format: DocstringFormat[](../tools/#pydantic_ai.tools.DocstringFormat "pydantic_ai.tools.DocstringFormat") = "auto",
 require_parameter_descriptions: bool[](https://docs.python.org/3/library/functions.html#bool) = False,
 schema_generator: type[](https://docs.python.org/3/library/functions.html#type)[
 GenerateJsonSchema[](https://docs.pydantic.dev/latest/api/json_schema/#pydantic.json_schema.GenerateJsonSchema "pydantic.json_schema.GenerateJsonSchema")
 ] = GenerateToolJsonSchema,
 strict: bool[](https://docs.python.org/3/library/functions.html#bool) | None = None,
 sequential: bool[](https://docs.python.org/3/library/functions.html#bool) = False,
 requires_approval: bool[](https://docs.python.org/3/library/functions.html#bool) = False,
 metadata: dict[](https://docs.python.org/3/library/stdtypes.html#dict)[str[](https://docs.python.org/3/library/stdtypes.html#str), Any[](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any")] | None = None,
 id: str[](https://docs.python.org/3/library/stdtypes.html#str) | None = None
)
```
Build a new function toolset.
Parameters:
Name | Type | Description | Default 
---|---|---|--- 
`tools` | `Sequence[](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "collections.abc.Sequence")[Tool[](../tools/#pydantic_ai.tools.Tool "pydantic_ai.tools.Tool")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")] | ToolFuncEither[](../tools/#pydantic_ai.tools.ToolFuncEither "pydantic_ai.tools.ToolFuncEither")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT"), ...]]` | The tools to add to the toolset. | `[]` 
`max_retries` | `int[](https://docs.python.org/3/library/functions.html#int)` | The maximum number of retries for each tool during a run. Applies to all tools, unless overridden when adding a tool. | `1` 
`docstring_format` | `DocstringFormat[](../tools/#pydantic_ai.tools.DocstringFormat "pydantic_ai.tools.DocstringFormat")` | Format of tool docstring, see [`DocstringFormat`](../tools/#pydantic_ai.tools.DocstringFormat). Defaults to `'auto'`, such that the format is inferred from the structure of the docstring. Applies to all tools, unless overridden when adding a tool. | `'auto'` 
`require_parameter_descriptions` | `bool[](https://docs.python.org/3/library/functions.html#bool)` | If True, raise an error if a parameter description is missing. Defaults to False. Applies to all tools, unless overridden when adding a tool. | `False` 
`schema_generator` | `type[](https://docs.python.org/3/library/functions.html#type)[GenerateJsonSchema[](https://docs.pydantic.dev/latest/api/json_schema/#pydantic.json_schema.GenerateJsonSchema "pydantic.json_schema.GenerateJsonSchema")]` | The JSON schema generator class to use for this tool. Defaults to `GenerateToolJsonSchema`. Applies to all tools, unless overridden when adding a tool. | `GenerateToolJsonSchema` 
`strict` | `bool[](https://docs.python.org/3/library/functions.html#bool) | None` | Whether to enforce JSON schema compliance (only affects OpenAI). See [`ToolDefinition`](../tools/#pydantic_ai.tools.ToolDefinition) for more info. | `None` 
`sequential` | `bool[](https://docs.python.org/3/library/functions.html#bool)` | Whether the function requires a sequential/serial execution environment. Defaults to False. Applies to all tools, unless overridden when adding a tool. | `False` 
`requires_approval` | `bool[](https://docs.python.org/3/library/functions.html#bool)` | Whether this tool requires human-in-the-loop approval. Defaults to False. See the [tools documentation](../../deferred-tools/#human-in-the-loop-tool-approval) for more info. Applies to all tools, unless overridden when adding a tool. | `False` 
`metadata` | `dict[](https://docs.python.org/3/library/stdtypes.html#dict)[str[](https://docs.python.org/3/library/stdtypes.html#str), Any[](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any")] | None` | Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization. Applies to all tools, unless overridden when adding a tool, which will be merged with the toolset's metadata. | `None` 
`id` | `str[](https://docs.python.org/3/library/stdtypes.html#str) | None` | An optional unique ID for the toolset. A toolset needs to have an ID in order to be used in a durable execution environment like Temporal, in which case the ID will be used to identify the toolset's activities within the workflow. | `None` 
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/function.py`
```
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
```
| ```
def__init__(
 self,
 tools: Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] = [],
 *,
 max_retries: int = 1,
 docstring_format: DocstringFormat = 'auto',
 require_parameter_descriptions: bool = False,
 schema_generator: type[GenerateJsonSchema] = GenerateToolJsonSchema,
 strict: bool | None = None,
 sequential: bool = False,
 requires_approval: bool = False,
 metadata: dict[str, Any] | None = None,
 id: str | None = None,
):
"""Build a new function toolset.
 Args:
 tools: The tools to add to the toolset.
 max_retries: The maximum number of retries for each tool during a run.
 Applies to all tools, unless overridden when adding a tool.
 docstring_format: Format of tool docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].
 Defaults to `'auto'`, such that the format is inferred from the structure of the docstring.
 Applies to all tools, unless overridden when adding a tool.
 require_parameter_descriptions: If True, raise an error if a parameter description is missing. Defaults to False.
 Applies to all tools, unless overridden when adding a tool.
 schema_generator: The JSON schema generator class to use for this tool. Defaults to `GenerateToolJsonSchema`.
 Applies to all tools, unless overridden when adding a tool.
 strict: Whether to enforce JSON schema compliance (only affects OpenAI).
 See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.
 sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.
 Applies to all tools, unless overridden when adding a tool.
 requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.
 See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.
 Applies to all tools, unless overridden when adding a tool.
 metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.
 Applies to all tools, unless overridden when adding a tool, which will be merged with the toolset's metadata.
 id: An optional unique ID for the toolset. A toolset needs to have an ID in order to be used in a durable execution environment like Temporal,
 in which case the ID will be used to identify the toolset's activities within the workflow.
 """
 self.max_retries = max_retries
 self._id = id
 self.docstring_format = docstring_format
 self.require_parameter_descriptions = require_parameter_descriptions
 self.schema_generator = schema_generator
 self.strict = strict
 self.sequential = sequential
 self.requires_approval = requires_approval
 self.metadata = metadata
 self.tools = {}
 for tool in tools:
 if isinstance(tool, Tool):
 self.add_tool(tool)
 else:
 self.add_function(tool)
```
---|--- 
#### tool
```
tool(
 func: ToolFuncEither[](../tools/#pydantic_ai.tools.ToolFuncEither "pydantic_ai.tools.ToolFuncEither")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT"), ToolParams[](../tools/#pydantic_ai.tools.ToolParams "pydantic_ai.tools.ToolParams")],
) -> ToolFuncEither[](../tools/#pydantic_ai.tools.ToolFuncEither "pydantic_ai.tools.ToolFuncEither")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT"), ToolParams[](../tools/#pydantic_ai.tools.ToolParams "pydantic_ai.tools.ToolParams")]
```
```
tool(
 *,
 name: str[](https://docs.python.org/3/library/stdtypes.html#str) | None = None,
 description: str[](https://docs.python.org/3/library/stdtypes.html#str) | None = None,
 retries: int[](https://docs.python.org/3/library/functions.html#int) | None = None,
 prepare: ToolPrepareFunc[](../tools/#pydantic_ai.tools.ToolPrepareFunc "pydantic_ai.tools.ToolPrepareFunc")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")] | None = None,
 docstring_format: DocstringFormat[](../tools/#pydantic_ai.tools.DocstringFormat "pydantic_ai.tools.DocstringFormat") | None = None,
 require_parameter_descriptions: bool[](https://docs.python.org/3/library/functions.html#bool) | None = None,
 schema_generator: (
 type[](https://docs.python.org/3/library/functions.html#type)[GenerateJsonSchema[](https://docs.pydantic.dev/latest/api/json_schema/#pydantic.json_schema.GenerateJsonSchema "pydantic.json_schema.GenerateJsonSchema")] | None
 ) = None,
 strict: bool[](https://docs.python.org/3/library/functions.html#bool) | None = None,
 sequential: bool[](https://docs.python.org/3/library/functions.html#bool) | None = None,
 requires_approval: bool[](https://docs.python.org/3/library/functions.html#bool) | None = None,
 metadata: dict[](https://docs.python.org/3/library/stdtypes.html#dict)[str[](https://docs.python.org/3/library/stdtypes.html#str), Any[](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any")] | None = None
) -> Callable[](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "collections.abc.Callable")[
 [ToolFuncEither[](../tools/#pydantic_ai.tools.ToolFuncEither "pydantic_ai.tools.ToolFuncEither")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT"), ToolParams[](../tools/#pydantic_ai.tools.ToolParams "pydantic_ai.tools.ToolParams")]],
 ToolFuncEither[](../tools/#pydantic_ai.tools.ToolFuncEither "pydantic_ai.tools.ToolFuncEither")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT"), ToolParams[](../tools/#pydantic_ai.tools.ToolParams "pydantic_ai.tools.ToolParams")],
]
```
```
tool(
 func: (
 ToolFuncEither[](../tools/#pydantic_ai.tools.ToolFuncEither "pydantic_ai.tools.ToolFuncEither")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT"), ToolParams[](../tools/#pydantic_ai.tools.ToolParams "pydantic_ai.tools.ToolParams")] | None
 ) = None,
 /,
 *,
 name: str[](https://docs.python.org/3/library/stdtypes.html#str) | None = None,
 description: str[](https://docs.python.org/3/library/stdtypes.html#str) | None = None,
 retries: int[](https://docs.python.org/3/library/functions.html#int) | None = None,
 prepare: ToolPrepareFunc[](../tools/#pydantic_ai.tools.ToolPrepareFunc "pydantic_ai.tools.ToolPrepareFunc")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")] | None = None,
 docstring_format: DocstringFormat[](../tools/#pydantic_ai.tools.DocstringFormat "pydantic_ai.tools.DocstringFormat") | None = None,
 require_parameter_descriptions: bool[](https://docs.python.org/3/library/functions.html#bool) | None = None,
 schema_generator: (
 type[](https://docs.python.org/3/library/functions.html#type)[GenerateJsonSchema[](https://docs.pydantic.dev/latest/api/json_schema/#pydantic.json_schema.GenerateJsonSchema "pydantic.json_schema.GenerateJsonSchema")] | None
 ) = None,
 strict: bool[](https://docs.python.org/3/library/functions.html#bool) | None = None,
 sequential: bool[](https://docs.python.org/3/library/functions.html#bool) | None = None,
 requires_approval: bool[](https://docs.python.org/3/library/functions.html#bool) | None = None,
 metadata: dict[](https://docs.python.org/3/library/stdtypes.html#dict)[str[](https://docs.python.org/3/library/stdtypes.html#str), Any[](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any")] | None = None,
) -> Any[](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any")
```
Decorator to register a tool function which takes [`RunContext`](../tools/#pydantic_ai.tools.RunContext) as its first argument.
Can decorate a sync or async functions.
The docstring is inspected to extract both the tool description and description of each parameter, [learn more](../../tools/#function-tools-and-schema).
We can't add overloads for every possible signature of tool, since the return type is a recursive union so the signature of functions decorated with `@toolset.tool` is obscured.
Example: 
```
frompydantic_aiimport Agent, FunctionToolset, RunContext
toolset = FunctionToolset()
@toolset.tool
deffoobar(ctx: RunContext[int], x: int) -> int:
 return ctx.deps + x
@toolset.tool(retries=2)
async defspam(ctx: RunContext[str], y: float) -> float:
 return ctx.deps + y
agent = Agent('test', toolsets=[toolset], deps_type=int)
result = agent.run_sync('foobar', deps=1)
print(result.output)
#> {"foobar":1,"spam":1.0}
```
Parameters:
Name | Type | Description | Default 
---|---|---|--- 
`func` | `ToolFuncEither[](../tools/#pydantic_ai.tools.ToolFuncEither "pydantic_ai.tools.ToolFuncEither")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT"), ToolParams[](../tools/#pydantic_ai.tools.ToolParams "pydantic_ai.tools.ToolParams")] | None` | The tool function to register. | `None` 
`name` | `str[](https://docs.python.org/3/library/stdtypes.html#str) | None` | The name of the tool, defaults to the function name. | `None` 
`description` | `str[](https://docs.python.org/3/library/stdtypes.html#str) | None` | The description of the tool,defaults to the function docstring. | `None` 
`retries` | `int[](https://docs.python.org/3/library/functions.html#int) | None` | The number of retries to allow for this tool, defaults to the agent's default retries, which defaults to 1. | `None` 
`prepare` | `ToolPrepareFunc[](../tools/#pydantic_ai.tools.ToolPrepareFunc "pydantic_ai.tools.ToolPrepareFunc")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")] | None` | custom method to prepare the tool definition for each step, return `None` to omit this tool from a given step. This is useful if you want to customise a tool at call time, or omit it completely from a step. See [`ToolPrepareFunc`](../tools/#pydantic_ai.tools.ToolPrepareFunc). | `None` 
`docstring_format` | `DocstringFormat[](../tools/#pydantic_ai.tools.DocstringFormat "pydantic_ai.tools.DocstringFormat") | None` | The format of the docstring, see [`DocstringFormat`](../tools/#pydantic_ai.tools.DocstringFormat). If `None`, the default value is determined by the toolset. | `None` 
`require_parameter_descriptions` | `bool[](https://docs.python.org/3/library/functions.html#bool) | None` | If True, raise an error if a parameter description is missing. If `None`, the default value is determined by the toolset. | `None` 
`schema_generator` | `type[](https://docs.python.org/3/library/functions.html#type)[GenerateJsonSchema[](https://docs.pydantic.dev/latest/api/json_schema/#pydantic.json_schema.GenerateJsonSchema "pydantic.json_schema.GenerateJsonSchema")] | None` | The JSON schema generator class to use for this tool. If `None`, the default value is determined by the toolset. | `None` 
`strict` | `bool[](https://docs.python.org/3/library/functions.html#bool) | None` | Whether to enforce JSON schema compliance (only affects OpenAI). See [`ToolDefinition`](../tools/#pydantic_ai.tools.ToolDefinition) for more info. If `None`, the default value is determined by the toolset. | `None` 
`sequential` | `bool[](https://docs.python.org/3/library/functions.html#bool) | None` | Whether the function requires a sequential/serial execution environment. Defaults to False. If `None`, the default value is determined by the toolset. | `None` 
`requires_approval` | `bool[](https://docs.python.org/3/library/functions.html#bool) | None` | Whether this tool requires human-in-the-loop approval. Defaults to False. See the [tools documentation](../../deferred-tools/#human-in-the-loop-tool-approval) for more info. If `None`, the default value is determined by the toolset. | `None` 
`metadata` | `dict[](https://docs.python.org/3/library/stdtypes.html#dict)[str[](https://docs.python.org/3/library/stdtypes.html#str), Any[](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any")] | None` | Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization. If `None`, the default value is determined by the toolset. If provided, it will be merged with the toolset's metadata. | `None` 
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/function.py`
```
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
```
| ```
deftool(
 self,
 func: ToolFuncEither[AgentDepsT, ToolParams] | None = None,
 /,
 *,
 name: str | None = None,
 description: str | None = None,
 retries: int | None = None,
 prepare: ToolPrepareFunc[AgentDepsT] | None = None,
 docstring_format: DocstringFormat | None = None,
 require_parameter_descriptions: bool | None = None,
 schema_generator: type[GenerateJsonSchema] | None = None,
 strict: bool | None = None,
 sequential: bool | None = None,
 requires_approval: bool | None = None,
 metadata: dict[str, Any] | None = None,
) -> Any:
"""Decorator to register a tool function which takes [`RunContext`][pydantic_ai.tools.RunContext] as its first argument.
 Can decorate a sync or async functions.
 The docstring is inspected to extract both the tool description and description of each parameter,
 [learn more](../tools.md#function-tools-and-schema).
 We can't add overloads for every possible signature of tool, since the return type is a recursive union
 so the signature of functions decorated with `@toolset.tool` is obscured.
 Example:
```python
 from pydantic_ai import Agent, FunctionToolset, RunContext
 toolset = FunctionToolset()
 @toolset.tool
 def foobar(ctx: RunContext[int], x: int) -> int:
 return ctx.deps + x
 @toolset.tool(retries=2)
 async def spam(ctx: RunContext[str], y: float) -> float:
 return ctx.deps + y
 agent = Agent('test', toolsets=[toolset], deps_type=int)
 result = agent.run_sync('foobar', deps=1)
 print(result.output)
 #> {"foobar":1,"spam":1.0}
```
 Args:
 func: The tool function to register.
 name: The name of the tool, defaults to the function name.
 description: The description of the tool,defaults to the function docstring.
 retries: The number of retries to allow for this tool, defaults to the agent's default retries,
 which defaults to 1.
 prepare: custom method to prepare the tool definition for each step, return `None` to omit this
 tool from a given step. This is useful if you want to customise a tool at call time,
 or omit it completely from a step. See [`ToolPrepareFunc`][pydantic_ai.tools.ToolPrepareFunc].
 docstring_format: The format of the docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].
 If `None`, the default value is determined by the toolset.
 require_parameter_descriptions: If True, raise an error if a parameter description is missing.
 If `None`, the default value is determined by the toolset.
 schema_generator: The JSON schema generator class to use for this tool.
 If `None`, the default value is determined by the toolset.
 strict: Whether to enforce JSON schema compliance (only affects OpenAI).
 See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.
 If `None`, the default value is determined by the toolset.
 sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.
 If `None`, the default value is determined by the toolset.
 requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.
 See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.
 If `None`, the default value is determined by the toolset.
 metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.
 If `None`, the default value is determined by the toolset. If provided, it will be merged with the toolset's metadata.
 """
 deftool_decorator(
 func_: ToolFuncEither[AgentDepsT, ToolParams],
 ) -> ToolFuncEither[AgentDepsT, ToolParams]:
 # noinspection PyTypeChecker
 self.add_function(
 func=func_,
 takes_ctx=None,
 name=name,
 description=description,
 retries=retries,
 prepare=prepare,
 docstring_format=docstring_format,
 require_parameter_descriptions=require_parameter_descriptions,
 schema_generator=schema_generator,
 strict=strict,
 sequential=sequential,
 requires_approval=requires_approval,
 metadata=metadata,
 )
 return func_
 return tool_decorator if func is None else tool_decorator(func)
```
---|--- 
#### add_function
```
add_function(
 func: ToolFuncEither[](../tools/#pydantic_ai.tools.ToolFuncEither "pydantic_ai.tools.ToolFuncEither")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT"), ToolParams[](../tools/#pydantic_ai.tools.ToolParams "pydantic_ai.tools.ToolParams")],
 takes_ctx: bool[](https://docs.python.org/3/library/functions.html#bool) | None = None,
 name: str[](https://docs.python.org/3/library/stdtypes.html#str) | None = None,
 description: str[](https://docs.python.org/3/library/stdtypes.html#str) | None = None,
 retries: int[](https://docs.python.org/3/library/functions.html#int) | None = None,
 prepare: ToolPrepareFunc[](../tools/#pydantic_ai.tools.ToolPrepareFunc "pydantic_ai.tools.ToolPrepareFunc")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")] | None = None,
 docstring_format: DocstringFormat[](../tools/#pydantic_ai.tools.DocstringFormat "pydantic_ai.tools.DocstringFormat") | None = None,
 require_parameter_descriptions: bool[](https://docs.python.org/3/library/functions.html#bool) | None = None,
 schema_generator: (
 type[](https://docs.python.org/3/library/functions.html#type)[GenerateJsonSchema[](https://docs.pydantic.dev/latest/api/json_schema/#pydantic.json_schema.GenerateJsonSchema "pydantic.json_schema.GenerateJsonSchema")] | None
 ) = None,
 strict: bool[](https://docs.python.org/3/library/functions.html#bool) | None = None,
 sequential: bool[](https://docs.python.org/3/library/functions.html#bool) | None = None,
 requires_approval: bool[](https://docs.python.org/3/library/functions.html#bool) | None = None,
 metadata: dict[](https://docs.python.org/3/library/stdtypes.html#dict)[str[](https://docs.python.org/3/library/stdtypes.html#str), Any[](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any")] | None = None,
) -> None
```
Add a function as a tool to the toolset.
Can take a sync or async function.
The docstring is inspected to extract both the tool description and description of each parameter, [learn more](../../tools/#function-tools-and-schema).
Parameters:
Name | Type | Description | Default 
---|---|---|--- 
`func` | `ToolFuncEither[](../tools/#pydantic_ai.tools.ToolFuncEither "pydantic_ai.tools.ToolFuncEither")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT"), ToolParams[](../tools/#pydantic_ai.tools.ToolParams "pydantic_ai.tools.ToolParams")]` | The tool function to register. | _required_ 
`takes_ctx` | `bool[](https://docs.python.org/3/library/functions.html#bool) | None` | Whether the function takes a [`RunContext`](../tools/#pydantic_ai.tools.RunContext) as its first argument. If `None`, this is inferred from the function signature. | `None` 
`name` | `str[](https://docs.python.org/3/library/stdtypes.html#str) | None` | The name of the tool, defaults to the function name. | `None` 
`description` | `str[](https://docs.python.org/3/library/stdtypes.html#str) | None` | The description of the tool, defaults to the function docstring. | `None` 
`retries` | `int[](https://docs.python.org/3/library/functions.html#int) | None` | The number of retries to allow for this tool, defaults to the agent's default retries, which defaults to 1. | `None` 
`prepare` | `ToolPrepareFunc[](../tools/#pydantic_ai.tools.ToolPrepareFunc "pydantic_ai.tools.ToolPrepareFunc")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")] | None` | custom method to prepare the tool definition for each step, return `None` to omit this tool from a given step. This is useful if you want to customise a tool at call time, or omit it completely from a step. See [`ToolPrepareFunc`](../tools/#pydantic_ai.tools.ToolPrepareFunc). | `None` 
`docstring_format` | `DocstringFormat[](../tools/#pydantic_ai.tools.DocstringFormat "pydantic_ai.tools.DocstringFormat") | None` | The format of the docstring, see [`DocstringFormat`](../tools/#pydantic_ai.tools.DocstringFormat). If `None`, the default value is determined by the toolset. | `None` 
`require_parameter_descriptions` | `bool[](https://docs.python.org/3/library/functions.html#bool) | None` | If True, raise an error if a parameter description is missing. If `None`, the default value is determined by the toolset. | `None` 
`schema_generator` | `type[](https://docs.python.org/3/library/functions.html#type)[GenerateJsonSchema[](https://docs.pydantic.dev/latest/api/json_schema/#pydantic.json_schema.GenerateJsonSchema "pydantic.json_schema.GenerateJsonSchema")] | None` | The JSON schema generator class to use for this tool. If `None`, the default value is determined by the toolset. | `None` 
`strict` | `bool[](https://docs.python.org/3/library/functions.html#bool) | None` | Whether to enforce JSON schema compliance (only affects OpenAI). See [`ToolDefinition`](../tools/#pydantic_ai.tools.ToolDefinition) for more info. If `None`, the default value is determined by the toolset. | `None` 
`sequential` | `bool[](https://docs.python.org/3/library/functions.html#bool) | None` | Whether the function requires a sequential/serial execution environment. Defaults to False. If `None`, the default value is determined by the toolset. | `None` 
`requires_approval` | `bool[](https://docs.python.org/3/library/functions.html#bool) | None` | Whether this tool requires human-in-the-loop approval. Defaults to False. See the [tools documentation](../../deferred-tools/#human-in-the-loop-tool-approval) for more info. If `None`, the default value is determined by the toolset. | `None` 
`metadata` | `dict[](https://docs.python.org/3/library/stdtypes.html#dict)[str[](https://docs.python.org/3/library/stdtypes.html#str), Any[](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any")] | None` | Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization. If `None`, the default value is determined by the toolset. If provided, it will be merged with the toolset's metadata. | `None` 
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/function.py`
```
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
```
| ```
defadd_function(
 self,
 func: ToolFuncEither[AgentDepsT, ToolParams],
 takes_ctx: bool | None = None,
 name: str | None = None,
 description: str | None = None,
 retries: int | None = None,
 prepare: ToolPrepareFunc[AgentDepsT] | None = None,
 docstring_format: DocstringFormat | None = None,
 require_parameter_descriptions: bool | None = None,
 schema_generator: type[GenerateJsonSchema] | None = None,
 strict: bool | None = None,
 sequential: bool | None = None,
 requires_approval: bool | None = None,
 metadata: dict[str, Any] | None = None,
) -> None:
"""Add a function as a tool to the toolset.
 Can take a sync or async function.
 The docstring is inspected to extract both the tool description and description of each parameter,
 [learn more](../tools.md#function-tools-and-schema).
 Args:
 func: The tool function to register.
 takes_ctx: Whether the function takes a [`RunContext`][pydantic_ai.tools.RunContext] as its first argument. If `None`, this is inferred from the function signature.
 name: The name of the tool, defaults to the function name.
 description: The description of the tool, defaults to the function docstring.
 retries: The number of retries to allow for this tool, defaults to the agent's default retries,
 which defaults to 1.
 prepare: custom method to prepare the tool definition for each step, return `None` to omit this
 tool from a given step. This is useful if you want to customise a tool at call time,
 or omit it completely from a step. See [`ToolPrepareFunc`][pydantic_ai.tools.ToolPrepareFunc].
 docstring_format: The format of the docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].
 If `None`, the default value is determined by the toolset.
 require_parameter_descriptions: If True, raise an error if a parameter description is missing.
 If `None`, the default value is determined by the toolset.
 schema_generator: The JSON schema generator class to use for this tool.
 If `None`, the default value is determined by the toolset.
 strict: Whether to enforce JSON schema compliance (only affects OpenAI).
 See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.
 If `None`, the default value is determined by the toolset.
 sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.
 If `None`, the default value is determined by the toolset.
 requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.
 See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.
 If `None`, the default value is determined by the toolset.
 metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.
 If `None`, the default value is determined by the toolset. If provided, it will be merged with the toolset's metadata.
 """
 if docstring_format is None:
 docstring_format = self.docstring_format
 if require_parameter_descriptions is None:
 require_parameter_descriptions = self.require_parameter_descriptions
 if schema_generator is None:
 schema_generator = self.schema_generator
 if strict is None:
 strict = self.strict
 if sequential is None:
 sequential = self.sequential
 if requires_approval is None:
 requires_approval = self.requires_approval
 tool = Tool[AgentDepsT](
 func,
 takes_ctx=takes_ctx,
 name=name,
 description=description,
 max_retries=retries,
 prepare=prepare,
 docstring_format=docstring_format,
 require_parameter_descriptions=require_parameter_descriptions,
 schema_generator=schema_generator,
 strict=strict,
 sequential=sequential,
 requires_approval=requires_approval,
 metadata=metadata,
 )
 self.add_tool(tool)
```
---|--- 
#### add_tool
```
add_tool(tool: Tool[](../tools/#pydantic_ai.tools.Tool "pydantic_ai.tools.Tool")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]) -> None
```
Add a tool to the toolset.
Parameters:
Name | Type | Description | Default 
---|---|---|--- 
`tool` | `Tool[](../tools/#pydantic_ai.tools.Tool "pydantic_ai.tools.Tool")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]` | The tool to add. | _required_ 
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/function.py`
```
301
302
303
304
305
306
307
308
309
310
311
312
313
```
| ```
defadd_tool(self, tool: Tool[AgentDepsT]) -> None:
"""Add a tool to the toolset.
 Args:
 tool: The tool to add.
 """
 if tool.name in self.tools:
 raise UserError(f'Tool name conflicts with existing tool: {tool.name!r}')
 if tool.max_retries is None:
 tool.max_retries = self.max_retries
 if self.metadata is not None:
 tool.metadata = self.metadata | (tool.metadata or {})
 self.tools[tool.name] = tool
```
---|--- 
### PrefixedToolset `dataclass`
Bases: `WrapperToolset[](#pydantic_ai.toolsets.WrapperToolset "pydantic_ai.toolsets.wrapper.WrapperToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]`
A toolset that prefixes the names of the tools it contains.
See [toolset docs](../../toolsets/#prefixing-tool-names) for more information.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/prefixed.py`
```
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
```
| ```
@dataclass
classPrefixedToolset(WrapperToolset[AgentDepsT]):
"""A toolset that prefixes the names of the tools it contains.
 See [toolset docs](../toolsets.md#prefixing-tool-names) for more information.
 """
 prefix: str
 @property
 deftool_name_conflict_hint(self) -> str:
 return 'Change the `prefix` attribute to avoid name conflicts.'
 async defget_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:
 return {
 new_name: replace(
 tool,
 toolset=self,
 tool_def=replace(tool.tool_def, name=new_name),
 )
 for name, tool in (await super().get_tools(ctx)).items()
 if (new_name := f'{self.prefix}_{name}')
 }
 async defcall_tool(
 self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]
 ) -> Any:
 original_name = name.removeprefix(self.prefix + '_')
 ctx = replace(ctx, tool_name=original_name)
 tool = replace(tool, tool_def=replace(tool.tool_def, name=original_name))
 return await super().call_tool(original_name, tool_args, ctx, tool)
```
---|--- 
### RenamedToolset `dataclass`
Bases: `WrapperToolset[](#pydantic_ai.toolsets.WrapperToolset "pydantic_ai.toolsets.wrapper.WrapperToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]`
A toolset that renames the tools it contains using a dictionary mapping new names to original names.
See [toolset docs](../../toolsets/#renaming-tools) for more information.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/renamed.py`
```
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
```
| ```
@dataclass
classRenamedToolset(WrapperToolset[AgentDepsT]):
"""A toolset that renames the tools it contains using a dictionary mapping new names to original names.
 See [toolset docs](../toolsets.md#renaming-tools) for more information.
 """
 name_map: dict[str, str]
 async defget_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:
 original_to_new_name_map = {v: k for k, v in self.name_map.items()}
 original_tools = await super().get_tools(ctx)
 tools: dict[str, ToolsetTool[AgentDepsT]] = {}
 for original_name, tool in original_tools.items():
 new_name = original_to_new_name_map.get(original_name, None)
 if new_name:
 tools[new_name] = replace(
 tool,
 toolset=self,
 tool_def=replace(tool.tool_def, name=new_name),
 )
 else:
 tools[original_name] = tool
 return tools
 async defcall_tool(
 self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]
 ) -> Any:
 original_name = self.name_map.get(name, name)
 ctx = replace(ctx, tool_name=original_name)
 tool = replace(tool, tool_def=replace(tool.tool_def, name=original_name))
 return await super().call_tool(original_name, tool_args, ctx, tool)
```
---|--- 
### PreparedToolset `dataclass`
Bases: `WrapperToolset[](#pydantic_ai.toolsets.WrapperToolset "pydantic_ai.toolsets.wrapper.WrapperToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]`
A toolset that prepares the tools it contains using a prepare function that takes the agent context and the original tool definitions.
See [toolset docs](../../toolsets/#preparing-tool-definitions) for more information.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/prepared.py`
```
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
```
| ```
@dataclass
classPreparedToolset(WrapperToolset[AgentDepsT]):
"""A toolset that prepares the tools it contains using a prepare function that takes the agent context and the original tool definitions.
 See [toolset docs](../toolsets.md#preparing-tool-definitions) for more information.
 """
 prepare_func: ToolsPrepareFunc[AgentDepsT]
 async defget_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:
 original_tools = await super().get_tools(ctx)
 original_tool_defs = [tool.tool_def for tool in original_tools.values()]
 prepared_tool_defs_by_name = {
 tool_def.name: tool_def for tool_def in (await self.prepare_func(ctx, original_tool_defs) or [])
 }
 if len(prepared_tool_defs_by_name.keys() - original_tools.keys()) > 0:
 raise UserError(
 'Prepare function cannot add or rename tools. Use `FunctionToolset.add_function()` or `RenamedToolset` instead.'
 )
 return {
 name: replace(original_tools[name], tool_def=tool_def)
 for name, tool_def in prepared_tool_defs_by_name.items()
 }
```
---|--- 
### WrapperToolset `dataclass`
Bases: `AbstractToolset[](#pydantic_ai.toolsets.AbstractToolset "pydantic_ai.toolsets.abstract.AbstractToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]`
A toolset that wraps another toolset and delegates to it.
See [toolset docs](../../toolsets/#wrapping-a-toolset) for more information.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/wrapper.py`
```
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
```
| ```
@dataclass
classWrapperToolset(AbstractToolset[AgentDepsT]):
"""A toolset that wraps another toolset and delegates to it.
 See [toolset docs](../toolsets.md#wrapping-a-toolset) for more information.
 """
 wrapped: AbstractToolset[AgentDepsT]
 @property
 defid(self) -> str | None:
 return None # pragma: no cover
 @property
 deflabel(self) -> str:
 return f'{self.__class__.__name__}({self.wrapped.label})'
 async def__aenter__(self) -> Self:
 await self.wrapped.__aenter__()
 return self
 async def__aexit__(self, *args: Any) -> bool | None:
 return await self.wrapped.__aexit__(*args)
 async defget_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:
 return await self.wrapped.get_tools(ctx)
 async defcall_tool(
 self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]
 ) -> Any:
 return await self.wrapped.call_tool(name, tool_args, ctx, tool)
 defapply(self, visitor: Callable[[AbstractToolset[AgentDepsT]], None]) -> None:
 self.wrapped.apply(visitor)
 defvisit_and_replace(
 self, visitor: Callable[[AbstractToolset[AgentDepsT]], AbstractToolset[AgentDepsT]]
 ) -> AbstractToolset[AgentDepsT]:
 return replace(self, wrapped=self.wrapped.visit_and_replace(visitor))
```
---|--- 
### ToolsetFunc `module-attribute`
```
ToolsetFunc: TypeAlias[](https://docs.python.org/3/library/typing.html#typing.TypeAlias "typing.TypeAlias") = Callable[](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "collections.abc.Callable")[
 [RunContext[](../tools/#pydantic_ai.tools.RunContext "pydantic_ai._run_context.RunContext")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]],
 AbstractToolset[](#pydantic_ai.toolsets.AbstractToolset "pydantic_ai.toolsets.abstract.AbstractToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")]
 | None
 | Awaitable[](https://docs.python.org/3/library/collections.abc.html#collections.abc.Awaitable "collections.abc.Awaitable")[AbstractToolset[](#pydantic_ai.toolsets.AbstractToolset "pydantic_ai.toolsets.abstract.AbstractToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai._run_context.AgentDepsT")] | None],
]
```
A sync/async function which takes a run context and returns a toolset.
### FastMCPToolset `dataclass`
Bases: `AbstractToolset[](#pydantic_ai.toolsets.AbstractToolset "pydantic_ai.toolsets.AbstractToolset")[AgentDepsT[](../tools/#pydantic_ai.tools.AgentDepsT "pydantic_ai.tools.AgentDepsT")]`
A FastMCP Toolset that uses the FastMCP Client to call tools from a local or remote MCP Server.
The Toolset can accept a FastMCP Client, a FastMCP Transport, or any other object which a FastMCP Transport can be created from.
See https://gofastmcp.com/clients/transports for a full list of transports available.
Source code in `pydantic_ai_slim/pydantic_ai/toolsets/fastmcp.py`
```
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
```
| ```
@dataclass(init=False)
classFastMCPToolset(AbstractToolset[AgentDepsT]):
"""A FastMCP Toolset that uses the FastMCP Client to call tools from a local or remote MCP Server.
 The Toolset can accept a FastMCP Client, a FastMCP Transport, or any other object which a FastMCP Transport can be created from.
 See https://gofastmcp.com/clients/transports for a full list of transports available.
 """
 client: Client[Any]
"""The FastMCP client to use."""
 _: KW_ONLY
 tool_error_behavior: Literal['model_retry', 'error']
"""The behavior to take when a tool error occurs."""
 max_retries: int
"""The maximum number of retries to attempt if a tool call fails."""
 _id: str | None
 def__init__(
 self,
 client: Client[Any]
 | ClientTransport
 | FastMCP
 | FastMCP1Server
 | AnyUrl
 | Path
 | MCPConfig
 | dict[str, Any]
 | str,
 *,
 max_retries: int = 1,
 tool_error_behavior: Literal['model_retry', 'error'] = 'model_retry',
 id: str | None = None,
 ) -> None:
 if isinstance(client, Client):
 self.client = client
 else:
 self.client = Client[Any](transport=client)
 self._id = id
 self.max_retries = max_retries
 self.tool_error_behavior = tool_error_behavior
 self._enter_lock: Lock = Lock()
 self._running_count: int = 0
 self._exit_stack: AsyncExitStack | None = None
 @property
 defid(self) -> str | None:
 return self._id
 async def__aenter__(self) -> Self:
 async with self._enter_lock:
 if self._running_count == 0:
 self._exit_stack = AsyncExitStack()
 await self._exit_stack.enter_async_context(self.client)
 self._running_count += 1
 return self
 async def__aexit__(self, *args: Any) -> bool | None:
 async with self._enter_lock:
 self._running_count -= 1
 if self._running_count == 0 and self._exit_stack:
 await self._exit_stack.aclose()
 self._exit_stack = None
 return None
 async defget_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:
 async with self:
 mcp_tools: list[MCPTool] = await self.client.list_tools()
 return {
 tool.name: _convert_mcp_tool_to_toolset_tool(toolset=self, mcp_tool=tool, retries=self.max_retries)
 for tool in mcp_tools
 }
 async defcall_tool(
 self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]
 ) -> Any:
 async with self:
 try:
 call_tool_result: CallToolResult = await self.client.call_tool(name=name, arguments=tool_args)
 except ToolError as e:
 if self.tool_error_behavior == 'model_retry':
 raise ModelRetry(message=str(e)) frome
 else:
 raise e
 # If we have structured content, return that
 if call_tool_result.structured_content:
 return call_tool_result.structured_content
 # Otherwise, return the content
 return _map_fastmcp_tool_results(parts=call_tool_result.content)
```
---|--- 
#### client `instance-attribute`
```
client: Client[Any[](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any")]
```
The FastMCP client to use.
#### max_retries `instance-attribute`
```
max_retries: int[](https://docs.python.org/3/library/functions.html#int) = max_retries
```
The maximum number of retries to attempt if a tool call fails.
#### tool_error_behavior `instance-attribute`
```
tool_error_behavior: Literal[](https://docs.python.org/3/library/typing.html#typing.Literal "typing.Literal")["model_retry", "error"] = (
 tool_error_behavior
)
```
The behavior to take when a tool error occurs.